<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ç¦éŸ³éº»é›€ - å®Œç¾é‚è¼¯ç‰ˆ</title>
    <style>
        :root { --tile-w: 42px; --tile-h: 56px; }
        * { box-sizing: border-box; }
        body {
            margin: 0; background-color: #054a29; font-family: "Microsoft JhengHei", sans-serif;
            overflow: hidden; display: flex; flex-direction: column; height: 100vh; height: 100dvh; 
            color: white; user-select: none; -webkit-user-select: none; touch-action: none;
        }
        
        /* é ‚éƒ¨ */
        header {
            flex-shrink: 0; height: 44px; padding: 0 8px; background: rgba(0,0,0,0.6); 
            display: flex; justify-content: space-between; align-items: center; z-index: 100; font-size: 14px;
        }
        select { padding: 4px; font-size: 14px; border-radius: 5px; border: 1px solid #ccc; background: #fff; max-width: 160px; }
        #status { font-size: 14px; font-weight: bold; background: rgba(0,0,0,0.3); padding: 4px 10px; border-radius: 12px; }
        
        /* éŠæˆ²å€ */
        #game-viewport {
            flex: 1; width: 100%; display: flex; justify-content: center; align-items: center; 
            position: relative; overflow: hidden; padding: 0;
        }
        #game-board { position: relative; transition: transform 0.2s ease; transform-origin: center center; }

        /* åº•éƒ¨ */
        footer { 
            flex-shrink: 0; height: 54px; padding: 5px; background: rgba(0,0,0,0.8); 
            display: flex; justify-content: space-around; align-items: center; z-index: 100;
            padding-bottom: max(5px, env(safe-area-inset-bottom));
        }
        .btn {
            background: linear-gradient(to bottom, #FFD700, #FFA000); border: none; padding: 0;
            width: 32%; height: 38px; border-radius: 19px; font-weight: bold; font-size: 15px; 
            box-shadow: 0 3px 0 #b8860b; cursor: pointer; display: flex; justify-content: center; 
            align-items: center; color: #333;
        }
        .btn:active { transform: translateY(2px); box-shadow: none; }
        .btn-blue { background: linear-gradient(to bottom, #4FC3F7, #039BE5); box-shadow: 0 3px 0 #0277BD; color: white; }

        /* éº»é›€ç‰Œ - ä¿®æ­£æµ®èµ·å•é¡Œ */
        .tile {
            position: absolute; width: var(--tile-w); height: var(--tile-h);
            background: #fdfdfd; border-radius: 6px; cursor: pointer;
            border: 1px solid #999; /* é‚Šæ¡†æ·±è‰²ä¸€é» */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: all 0.1s;
        }
        
        /* è¦–è¦ºä¿®æ­£ï¼šä¸åŒå±¤ç´šæœ‰ä¸åŒé™°å½± */
        .tile[data-layer="0"] { box-shadow: 1px 1px 0 #bbb; } /* åº•å±¤ï¼šå¹¾ä¹ç„¡é™°å½±ï¼Œè²¼åœ° */
        .tile[data-layer="1"] { box-shadow: 2px 2px 2px rgba(0,0,0,0.3), 2px 2px 0 #bbb; }
        .tile[data-layer="2"] { box-shadow: 3px 3px 4px rgba(0,0,0,0.4), 3px 3px 0 #bbb; }
        .tile[data-layer="3"] { box-shadow: 4px 4px 6px rgba(0,0,0,0.5), 4px 4px 0 #bbb; }
        
        .t-suit { position: absolute; top: 2px; right: 3px; font-size: 10px; color: #888; line-height: 1; }
        .t-icon { font-size: 28px; line-height: 1; margin-top: 2px; }
        .t-text { font-size: 11px; font-weight: 900; margin-top: 0px; color: #333; }
        
        .tile.locked { filter: brightness(0.65) contrast(0.9); cursor: default; } /* é–ä½æ™‚ç¨å¾®å…‰äº®ä¸€é»é»ï¼Œä¸è¦å¤ªé»‘ */
        .tile.selected { background: #fff59d; border: 2px solid #ff3d00; transform: translate(-1px, -1px); z-index: 999 !important; }
        .c-red { color: #d32f2f; } .c-blue { color: #1976d2; } .c-green { color: #388e3c; }

        /* å½ˆçª— */
        #msg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center; padding: 20px;
        }
        .overlay-title { font-size: 32px; font-weight: bold; margin-bottom: 20px; }
        .overlay-verse { 
            font-size: 20px; color: #fff; line-height: 1.5; 
            background: rgba(255,255,255,0.15); padding: 25px; border-radius: 15px; 
            width: 100%; max-width: 400px;
        }
    </style>
</head>
<body>

<header>
    <select id="map-select" onchange="changeMap(this.value)">
        <option value="turtle">ğŸ¢ ç¶“å…¸é¾œèƒŒ</option>
        <option value="castle">ğŸ° å …å›ºå ¡å£˜</option>
        <option value="cross">âœï¸ æ¦®è€€åæ¶</option>
        <option value="bridge">ğŸŒ‰ æ©å…¸ä¹‹æ©‹</option>
        <option value="random">ğŸ² éš¨æ©Ÿçµæ§‹</option>
    </select>
    <div id="status">å‰©é¤˜: 0</div>
</header>

<div id="game-viewport">
    <div id="game-board"></div>
</div>

<footer>
    <button class="btn btn-blue" onclick="forceNewGame()">ğŸ”„ æ–°å±€</button>
    <button class="btn" onclick="shuffleActiveTiles()">ğŸ”€ æ´—ç‰Œ</button>
    <button class="btn" onclick="autoHint()">ğŸ’¡ æç¤º</button>
</footer>

<div id="msg-overlay">
    <div id="overlay-title" class="overlay-title" style="color:#FFD700;">å“ˆåˆ©è·¯äºï¼</div>
    <div id="overlay-verse" class="overlay-verse"></div>
    <button id="overlay-btn" class="btn" style="width: 220px; margin-top: 30px; height: 50px; font-size: 18px;" onclick="forceNewGame()">æŒ‘æˆ°ä¸‹ä¸€é—œ</button>
</div>

<script>
    const rawTiles = [
        {t:"æ‘©è¥¿", i:"ğŸŒŠ", s:"è¬", c:"c-red"}, {t:"å¤§è¡›", i:"ğŸ‘‘", s:"è¬", c:"c-red"},
        {t:"ä¿ç¾…", i:"ğŸ“œ", s:"è¬", c:"c-red"}, {t:"å½¼å¾—", i:"ğŸŸ", s:"è¬", c:"c-red"},
        {t:"ç´„æ‹¿", i:"ğŸ‹", s:"è¬", c:"c-red"}, {t:"é¦¬åˆ©äº", i:"ğŸ¤°", s:"è¬", c:"c-red"},
        {t:"è€¶äº¬", i:"ğŸ°", s:"ç­’", c:"c-blue"}, {t:"è¥¿å¥ˆ", i:"â›°ï¸", s:"ç­’", c:"c-blue"},
        {t:"ç´…æµ·", i:"ğŸŒŠ", s:"ç­’", c:"c-blue"}, {t:"ä¼Šç”¸", i:"ğŸ", s:"ç­’", c:"c-blue"},
        {t:"åŠ åˆ©åˆ©", i:"ğŸ›¶", s:"ç­’", c:"c-blue"}, {t:"è–æ®¿", i:"ğŸ›ï¸", s:"ç­’", c:"c-blue"},
        {t:"åæ¶", i:"âœï¸", s:"ç´¢", c:"c-green"}, {t:"è–ç¶“", i:"ğŸ“–", s:"ç´¢", c:"c-green"},
        {t:"äº”é¤…", i:"ğŸ", s:"ç´¢", c:"c-green"}, {t:"äºŒé­š", i:"ğŸŸ", s:"ç´¢", c:"c-green"},
        {t:"å¯¶è¡€", i:"ğŸ·", s:"ç´¢", c:"c-green"}, {t:"è–éˆ", i:"ğŸ•Šï¸", s:"ç´¢", c:"c-green"},
        {t:"ä¿¡", i:"ğŸ›¡ï¸", s:"ç•ª", c:"#333"}, {t:"æœ›", i:"âš“", s:"ç•ª", c:"#333"},
        {t:"æ„›", i:"â¤ï¸", s:"ç•ª", c:"#333"}, {t:"é˜¿å€‘", i:"ğŸ™", s:"ç•ª", c:"#333"}
    ];
    
    const winVerses = [
        "æµæ·šæ’’ç¨®çš„ï¼Œå¿…æ­¡å‘¼æ”¶å‰²ã€‚(è©© 126:5)", "é‚£ç¾å¥½çš„ä»—æˆ‘å·²ç¶“æ‰“éäº†ã€‚(æå¾Œ 4:7)",
        "é è‘—é‚£åŠ çµ¦æˆ‘åŠ›é‡çš„ï¼Œå‡¡äº‹éƒ½èƒ½åšã€‚(è…“ 4:13)", "ä½ å€‘æ˜¯ä¸–ä¸Šçš„å…‰ã€‚(å¤ª 5:14)",
        "å¾—å‹çš„ï¼Œæˆ‘è¦è³œä»–åœ¨æˆ‘å¯¶åº§ä¸Šèˆ‡æˆ‘åŒåã€‚(å•Ÿ 3:21)"
    ];
    const loseVerses = [
        "æˆ‘çš„æ©å…¸æ˜¯å¤ ä½ ç”¨çš„ã€‚(æ—å¾Œ 12:9)", "æ‡‰ç•¶ä¸€ç„¡æ›æ…®ï¼Œåªè¦å‡¡äº‹è—‰è‘—ç¦±å‘Šã€‚(è…“ 4:6)",
        "ä½ å€‘è¦ä¼‘æ¯ï¼Œè¦çŸ¥é“æˆ‘æ˜¯ç¥ã€‚(è©© 46:10)", "è¬äº‹éƒ½äº’ç›¸æ•ˆåŠ›ã€‚(ç¾… 8:28)"
    ];

    // --- åœ°åœ–çµæ§‹å®šç¾© (åªå®šç¾©ä½ç½®ï¼Œä¸æ”¾ç‰Œ) ---
    // é€™è£¡å®šç¾©çš„æ˜¯ã€Œä½ç½®æ§½ä½ (Slots)ã€ï¼Œæ ¼å¼: [z, r, c]
    const MapBlueprints = {
        turtle: () => generatePyramid(6, 8, [6,6, 4,4, 2,2, 1,1]), 
        castle: () => generateWall(6, 8),
        cross: () => generateCross(),
        bridge: () => generateBridge(),
        random: () => generateChaos()
    };

    function generatePyramid(rows, cols, layerSizes) {
        let slots = [];
        let currentLayer = 0;
        for(let i=0; i<layerSizes.length; i+=2) {
            let h = layerSizes[i], w = layerSizes[i+1];
            let startR = Math.floor((rows - h)/2), startC = Math.floor((cols - w)/2);
            for(let r=0; r<h; r++) for(let c=0; c<w; c++) slots.push([currentLayer, startR+r, startC+c]);
            currentLayer++;
        }
        return slots;
    }
    function generateWall(rows, cols) {
        let slots = [];
        for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
            slots.push([0, r, c]);
            if(r===0 || r===rows-1 || c===0 || c===cols-1) slots.push([1, r, c]); 
        }
        return slots;
    }
    function generateCross() {
        let slots = [];
        for(let r=0; r<8; r++) { slots.push([0, r, 3]); slots.push([0, r, 4]); slots.push([1, r, 3]); }
        for(let c=0; c<8; c++) { slots.push([0, 2, c]); slots.push([0, 3, c]); slots.push([1, 2, c]); }
        slots.push([2, 2, 3]); slots.push([2, 3, 3]);
        return slots;
    }
    function generateBridge() {
        let slots = [];
        for(let c=0; c<10; c++) {
            slots.push([0, 2, c]); slots.push([0, 3, c]);
            if(c<3 || c>6) { slots.push([1, 2, c]); slots.push([1, 3, c]); slots.push([2, 2, c]); }
        }
        return slots;
    }
    function generateChaos() {
        let slots = [];
        for(let r=0; r<6; r++) for(let c=0; c<8; c++) slots.push([0, r, c]); // åº•åº§
        for(let i=0; i<30; i++) {
            slots.push([1, Math.floor(Math.random()*4)+1, Math.floor(Math.random()*6)+1]);
        }
        return slots;
    }

    // --- éŠæˆ²é‚è¼¯ ---
    let tiles = [];
    let selectedTile = null;
    let tileW = 42, tileH = 56;

    function changeMap(val) { startGame(val); }
    function forceNewGame() { startGame(document.getElementById('map-select').value); }

    // æ ¸å¿ƒï¼šé€†å‘ç”Ÿæˆæ¼”ç®—æ³• (Reverse Generation)
    // 1. å–å¾—æ‰€æœ‰ä½ç½®æ§½ä½ (Slots)
    // 2. å¾ç‰Œåº«éš¨æ©ŸæŠ½ä¸€å°ç‰Œ
    // 3. å°‹æ‰¾å…©å€‹ã€Œç›®å‰å¯ä»¥æ”¾ç½®ã€çš„ä½ç½® (å³ï¼šå¦‚æœç¾åœ¨æ”¾ä¸‹å»ï¼Œå°‡ä¾†å¯ä»¥è¢«æ‹¿èµ°)
    //    -> é€™è£¡çš„ã€Œå°‡ä¾†å¯ä»¥æ‹¿èµ°ã€åœ¨é€†å‘éç¨‹ä¸­ï¼Œç­‰åŒæ–¼ã€Œæ”¾ç½®æ™‚ä¸æœƒé•åè¦å‰‡ã€
    //    -> ä½†é€†å‘æ€è€ƒæ¯”è¼ƒè¤‡é›œï¼Œæˆ‘å€‘ç”¨ä¸€å€‹æ›´ç°¡å–®çš„ã€Œä¿è­‰æœ‰è§£æ´—ç‰Œæ³•ã€(Solvable Shuffle)
    
    // æ”¹è‰¯ç‰ˆç­–ç•¥ï¼š
    // æˆ‘å€‘å…ˆç”Ÿç”¢å‡ºæœ‰è§£çš„ç‰Œåºï¼Œå†å¡«å…¥åœ°åœ–ã€‚
    // æ–¹æ³•ï¼š
    // 1. å»ºç«‹åœ°åœ–çµæ§‹ã€‚
    // 2. æ¨¡æ“¬ç©éŠæˆ²ï¼šå¾åœ°åœ–ä¸­ã€Œå¯é¸ã€çš„ä½ç½®è£¡ï¼Œéš¨æ©Ÿé¸å…©å¼µï¼Œæ¨™è¨˜ç‚ºã€Œä¸€å°ã€ã€‚
    // 3. æŠŠé€™å…©å¼µç§»å‡ºåœ°åœ–ï¼Œé‡è¤‡æ­¥é©Ÿ2ï¼Œç›´åˆ°åœ°åœ–æ¸…ç©ºã€‚
    // 4. è¨˜éŒ„ä¸‹é€™å€‹ã€Œé…å°é †åºã€ã€‚
    // 5. çœŸæ­£é–‹å§‹éŠæˆ²æ™‚ï¼Œå°‡ç›¸åŒçš„ç‰Œå¡«å…¥å‰›æ‰è¨˜éŒ„çš„é…å°ä½ç½®ä¸­ã€‚
    
    function startGame(mapType) {
        document.getElementById('msg-overlay').style.display = 'none';
        const board = document.getElementById('game-board');
        board.innerHTML = '';
        tiles = [];
        selectedTile = null;

        // 1. ç²å–åœ°åœ–æ§½ä½
        let slots = MapBlueprints[mapType]();
        // å¿…é ˆæ˜¯å¶æ•¸
        if(slots.length % 2 !== 0) slots.pop();

        // 2. å»ºç«‹è™›æ“¬ç‰Œçµ„ç‰©ä»¶ç”¨ä¾†é‹ç®—
        let virtualTiles = slots.map((s, i) => ({
            id: i, z: s[0], r: s[1], c: s[2], 
            active: true, // åœ¨æ¨¡æ“¬ä¸­ï¼Œactive ä»£è¡¨ã€Œé‚„åœ¨å ´ä¸Šã€
            pairId: null  // ç”¨ä¾†è¨˜éŒ„å®ƒè·Ÿèª°ä¸€å°
        }));

        // 3. é€†å‘é…å° (æ¨¡æ“¬æ¶ˆé™¤éç¨‹)
        // ç‚ºäº†ä¿è­‰æœ‰è§£ï¼Œæˆ‘å€‘æ¨¡æ“¬ã€Œæ¶ˆé™¤ã€ã€‚
        // åœ¨æ¨¡æ“¬ä¸­ï¼Œæˆ‘å€‘æ¯æ¬¡å¾ã€Œå¯é¸ç‰Œã€ä¸­éš¨æ©Ÿé¸å…©å¼µï¼Œè¨­ç‚ºä¸€çµ„é…å°ï¼Œç„¶å¾Œç§»é™¤ã€‚
        // é‡è¤‡ç›´åˆ°æ¸…ç©ºã€‚
        let pairs = [];
        let tempTiles = JSON.parse(JSON.stringify(virtualTiles)); // è¤‡è£½ä¸€ä»½
        
        // ç‚ºäº†é˜²æ­¢éš¨æ©Ÿé¸æ“‡å°è‡´æ­»å±€ (é›–ç„¶æ©Ÿç‡ä½)ï¼Œæˆ‘å€‘å˜—è©¦æœ€å¤š 10 æ¬¡
        let success = false;
        let attempt = 0;

        while(!success && attempt < 20) {
            tempTiles = JSON.parse(JSON.stringify(virtualTiles));
            pairs = [];
            let possible = true;
            
            while(tempTiles.some(t => t.active)) {
                // æ‰¾å‡ºæ‰€æœ‰ç¾åœ¨èƒ½æ‹¿çš„ç‰Œ (æœªè¢«é®æ“‹)
                let available = getAvailableTiles(tempTiles);
                
                if(available.length < 2) {
                    possible = false; // æ­»å±€
                    break;
                }
                
                // éš¨æ©Ÿé¸å…©å¼µ
                let idx1 = Math.floor(Math.random() * available.length);
                let tile1 = available[idx1];
                available.splice(idx1, 1); // ç§»å‡ºé™£åˆ—ä»¥å…é‡è¤‡é¸
                
                let idx2 = Math.floor(Math.random() * available.length);
                let tile2 = available[idx2];
                
                // è¨˜éŒ„é€™å…©å¼µæ˜¯ä¸€å°
                pairs.push([tile1.id, tile2.id]);
                
                // å¾å ´ä¸Šç§»é™¤ (æ¨¡æ“¬æ¶ˆé™¤)
                tile1.active = false;
                tile2.active = false;
            }
            
            if(possible) success = true;
            attempt++;
        }

        if(!success) {
            // æ¥µç«¯æƒ…æ³ fallback: éš¨æ©Ÿç™¼ç‰Œ (æ¥µå°‘ç™¼ç”Ÿ)
            console.log("Fallback to random");
            pairs = [];
            for(let i=0; i<virtualTiles.length; i+=2) {
                pairs.push([i, i+1]); // å‡é…å°
            }
        }

        // 4. å¡«å…¥çœŸå¯¦èŠ±è‰²
        // æˆ‘å€‘æœ‰ä¸€çµ„é…å°åˆ—è¡¨ (pairs)ï¼Œç¾åœ¨æŠŠèŠ±è‰²å¡«é€²å»
        // æ¯å€‹ pair åˆ†é…ä¸€å€‹èŠ±è‰²
        let finalTilesData = new Array(virtualTiles.length);
        
        pairs.forEach(pair => {
            // éš¨æ©Ÿé¸ä¸€å€‹èŠ±è‰²
            let card = rawTiles[Math.floor(Math.random() * rawTiles.length)];
            // è³¦äºˆé€™å…©å¼µç‰Œ
            finalTilesData[pair[0]] = card;
            finalTilesData[pair[1]] = card;
        });

        // 5. æ¸²æŸ“çœŸå¯¦ç•«é¢
        renderTiles(virtualTiles, finalTilesData);
        
        setTimeout(fitBoard, 50);
        updateStatusText();
    }

    // è¼”åŠ©ï¼šåˆ¤æ–·å“ªäº›ç‰Œå¯ä»¥æ‹¿ (æ¨¡æ“¬ç”¨)
    function getAvailableTiles(tileSet) {
        let available = [];
        for(let tile of tileSet) {
            if(!tile.active) continue;
            if(!checkLockedInSet(tile, tileSet)) {
                available.push(tile);
            }
        }
        return available;
    }

    function checkLockedInSet(tile, tileSet) {
        let hasTop = false, hasLeft = false, hasRight = false;
        for(let other of tileSet) {
            if(!other.active || other.id === tile.id) continue;
            // æª¢æŸ¥é®æ“‹ (åŒæ¨£çš„é‚è¼¯)
            if(other.z === tile.z + 1 && other.r === tile.r && other.c === tile.c) hasTop = true;
            if(other.z === tile.z && other.r === tile.r) {
                if(other.c === tile.c - 1) hasLeft = true;
                if(other.c === tile.c + 1) hasRight = true;
            }
        }
        return hasTop || (hasLeft && hasRight);
    }

    function renderTiles(slots, dataMap) {
        const board = document.getElementById('game-board');
        let maxX = 0, maxY = 0;
        
        slots.forEach((slot, index) => {
            if(slot.c > maxX) maxX = slot.c;
            if(slot.r > maxY) maxY = slot.r;
            
            const el = document.createElement('div');
            el.className = 'tile';
            el.setAttribute('data-layer', slot.z); // ç”¨æ–¼ CSS é™°å½±æ§åˆ¶
            
            const card = dataMap[index];
            el.innerHTML = `<div class="t-suit">${card.s}</div><div class="t-icon ${card.c}">${card.i}</div><div class="t-text ${card.c}">${card.t}</div>`;
            
            let left = slot.c * tileW + (slot.z * 2); // æ¸›å°‘åç§»
            let top = slot.r * tileH - (slot.z * 4); 
            el.style.left = left + 'px'; el.style.top = top + 'px'; el.style.zIndex = slot.z * 10 + slot.r; 
            
            const tileObj = { 
                el: el, data: card, 
                z: slot.z, r: slot.r, c: slot.c, 
                active: true, id: index 
            };
            el.onclick = () => onTileClick(tileObj);
            board.appendChild(el);
            tiles.push(tileObj);
        });
        
        board.style.width = (maxX + 1) * tileW + 10 + 'px';
        board.style.height = (maxY + 1) * tileH + 10 + 'px';
        
        updateLockStatus();
    }

    // --- æ¨™æº–éŠæˆ²é‚è¼¯ ---

    function updateLockStatus() {
        tiles.forEach(t => {
            if(!t.active) return;
            t.isLocked = checkLocked(t);
            if(t.isLocked) t.el.classList.add('locked');
            else t.el.classList.remove('locked');
        });
    }

    function checkLocked(tile) {
        // ä½¿ç”¨çœŸå¯¦çš„ tiles é™£åˆ—
        let hasTop = false, hasLeft = false, hasRight = false;
        for(let other of tiles) {
            if(!other.active || other === tile) continue;
            if(other.z === tile.z + 1 && other.r === tile.r && other.c === tile.c) hasTop = true;
            if(other.z === tile.z && other.r === tile.r) {
                if(other.c === tile.c - 1) hasLeft = true;
                if(other.c === tile.c + 1) hasRight = true;
            }
        }
        return hasTop || (hasLeft && hasRight);
    }

    function onTileClick(tile) {
        if(!tile.active || tile.isLocked) return;
        if(selectedTile === tile) {
            tile.el.classList.remove('selected'); selectedTile = null;
        } else if(selectedTile) {
            if(tile.data.t === selectedTile.data.t) {
                tile.active = false; selectedTile.active = false;
                tile.el.style.opacity = 0; selectedTile.el.style.opacity = 0;
                tile.el.style.transform = "scale(0)"; selectedTile.el.style.transform = "scale(0)";
                selectedTile = null;
                setTimeout(() => {
                    tile.el.style.display = 'none'; 
                    updateLockStatus(); 
                    updateStatusText();
                    checkGameState(); 
                }, 200);
            } else {
                selectedTile.el.classList.remove('selected'); selectedTile = tile; tile.el.classList.add('selected');
            }
        } else {
            selectedTile = tile; tile.el.classList.add('selected');
        }
    }

    function checkGameState() {
        let count = tiles.filter(t => t.active).length;
        if (count === 0) showModal('win');
        else if (!hasAvailableMoves()) showModal('lose');
    }

    function hasAvailableMoves() {
        let freeTiles = tiles.filter(t => t.active && !t.isLocked);
        for(let i=0; i<freeTiles.length; i++) {
            for(let j=i+1; j<freeTiles.length; j++) {
                if(freeTiles[i].data.t === freeTiles[j].data.t) return true;
            }
        }
        return false;
    }

    function showModal(type) {
        const overlay = document.getElementById('msg-overlay');
        const titleEl = document.getElementById('overlay-title');
        const verseEl = document.getElementById('overlay-verse');
        const btnEl = document.getElementById('overlay-btn');

        if (type === 'win') {
            titleEl.innerText = "å“ˆåˆ©è·¯äºï¼(å‹åˆ©)";
            titleEl.style.color = "#FFD700"; 
            verseEl.innerText = winVerses[Math.floor(Math.random() * winVerses.length)];
            btnEl.innerText = "æŒ‘æˆ°ä¸‹ä¸€é—œ";
            btnEl.onclick = () => {
                const maps = ['turtle', 'castle', 'cross', 'bridge', 'random'];
                const nextMap = maps[Math.floor(Math.random() * maps.length)];
                document.getElementById('map-select').value = nextMap;
                startGame(nextMap);
            };
        } else {
            titleEl.innerText = "æ©å…¸å¤ ç”¨ (æš«æ™‚ç„¡è·¯)";
            titleEl.style.color = "#4FC3F7"; 
            verseEl.innerText = loseVerses[Math.floor(Math.random() * loseVerses.length)];
            btnEl.innerText = "é‡æ–°é–‹å§‹";
            btnEl.onclick = () => forceNewGame();
        }
        overlay.style.display = 'flex';
    }

    // --- æ™ºèƒ½æ´—ç‰Œ (ä¿è­‰æ´—å®Œæœ‰å¾—ç©) ---
    function shuffleActiveTiles() {
        let activeTiles = tiles.filter(t => t.active);
        let datas = activeTiles.map(t => t.data);
        
        // å˜—è©¦æ´—ç‰Œç›´åˆ°æœ‰è§£
        let attempt = 0; 
        let solvable = false;
        
        // æ‰¾å‡ºæ‰€æœ‰æœªé–å®šçš„ä½ç½®ç´¢å¼•
        let freeIndices = [];
        activeTiles.forEach((t, idx) => { if(!checkLocked(t)) freeIndices.push(idx); });

        while(!solvable && attempt < 50) {
            datas.sort(() => Math.random() - 0.5);
            // æª¢æŸ¥æ˜¯å¦è‡³å°‘æœ‰ä¸€å°åœ¨ freeIndices ä¸­
            let freeDatas = freeIndices.map(i => datas[i]);
            let seen = new Set();
            for(let d of freeDatas) { 
                if(seen.has(d.t)) { solvable = true; break; } 
                seen.add(d.t); 
            }
            attempt++;
        }

        activeTiles.forEach((t, i) => {
            t.data = datas[i]; t.el.classList.remove('selected');
            t.el.innerHTML = `<div class="t-suit">${t.data.s}</div><div class="t-icon ${t.data.c}">${t.data.i}</div><div class="t-text ${t.data.c}">${t.data.t}</div>`;
        });
        selectedTile = null;
        const b = document.getElementById('game-board');
        b.style.opacity = 0.5; setTimeout(() => b.style.opacity = 1, 300);
        
        if(!solvable) alert("ç‰Œå±€éæ–¼è¤‡é›œï¼Œå»ºè­°ç›´æ¥é–‹æ–°å±€ï¼");
    }

    function autoHint() {
        let freeTiles = tiles.filter(t => t.active && !t.isLocked);
        for(let i=0; i<freeTiles.length; i++) for(let j=i+1; j<freeTiles.length; j++) {
            if(freeTiles[i].data.t === freeTiles[j].data.t) {
                freeTiles[i].el.style.background = '#81d4fa'; freeTiles[j].el.style.background = '#81d4fa';
                setTimeout(() => { freeTiles[i].el.style.background = ''; freeTiles[j].el.style.background = ''; }, 1500);
                return;
            }
        }
        alert("ç›®å‰ç„¡è§£ï¼Œè«‹æŒ‰ã€Œæ´—ç‰Œã€ï¼");
    }

    function updateStatusText() {
        let count = tiles.filter(t => t.active).length;
        document.getElementById('status').innerText = "å‰©é¤˜: " + count;
    }

    function fitBoard() {
        const board = document.getElementById('game-board');
        const view = document.getElementById('game-viewport');
        if(!board || !view) return;
        board.style.transform = 'scale(1)'; 
        const scale = Math.min(view.clientWidth / board.scrollWidth, view.clientHeight / board.scrollHeight);
        board.style.transform = `scale(${scale * 0.96})`;
    }
    window.addEventListener('resize', fitBoard);
    startGame('random'); 

</script>
</body>
</html>
