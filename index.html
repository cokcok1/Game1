<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-title" content="Á¶èÈü≥È∫ªÈõÄ">
    <meta name="application-name" content="Á¶èÈü≥È∫ªÈõÄ">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#054a29">
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="https://cokcok1.github.io/Game1/mj.png">
    <link rel="icon" type="image/png" href="https://cokcok1.github.io/Game1/mj.png">

    <title>Á¶èÈü≥È∫ªÈõÄ - v35.1 ‰øÆÂæ©Áâà</title>
    <style>
        :root { 
            --tile-w: 44px; 
            --tile-h: 58px; 
            --depth: 12px; 
            --bg-color: #87ceeb; 
            --ui-cloud-bg: rgba(255, 255, 255, 0.3);
            --text-dark: #fff;
            --btn-yellow-1: #ffd54f; --btn-yellow-2: #ffb300;
            --btn-blue-1: #4fc3f7; --btn-blue-2: #0288d1;
            --btn-orange-1: #ffab91; --btn-orange-2: #d84315;
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; 
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at top left, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 50%),
                linear-gradient(to bottom, #4facfe 0%, #00f2fe 100%);
            background-size: cover; background-attachment: fixed;
            font-family: "Comic Sans MS", "Chalkboard SE", "ÂπºÂúÜ", "Microsoft JhengHei", sans-serif;
            overflow: hidden; display: flex; flex-direction: column; height: 100vh; height: 100dvh; 
            color: var(--text-dark); user-select: none; -webkit-user-select: none; touch-action: none;
        }
        
        header, footer, .overlay-box, #joystick-zone, #status {
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            background: rgba(255, 255, 255, 0.25) !important;
            border: 1px solid rgba(255, 255, 255, 0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        header {
            flex-shrink: 0; height: calc(50px + env(safe-area-inset-top)); 
            padding: 5px 15px; padding-top: calc(5px + env(safe-area-inset-top)); 
            display: flex; justify-content: space-between; align-items: center; z-index: 100; font-size: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; margin: 0 10px 5px 10px;
        }

        select { 
            padding: 6px 10px; font-size: 14px; border-radius: 15px; 
            border: 1px solid rgba(255, 255, 255, 0.6); background: rgba(0, 60, 120, 0.6) !important;
            max-width: 140px; color: #fff; font-weight: bold; box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
        }
        option { background: #333; color: #fff; }
        
        #status { font-size: 15px; font-weight: bold; background: rgba(255, 213, 79, 0.85) !important; color: #d84315; padding: 6px 15px; border-radius: 20px; box-shadow: 0 3px 0 #ffca28, 0 5px 10px rgba(0,0,0,0.2); text-shadow: none; }
        
        #game-viewport {
            flex: 1; width: 100%; position: relative; overflow: hidden; padding: 0;
            perspective: 2000px; perspective-origin: center center;
        }

        #game-board { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%) rotateX(30deg) rotateZ(0deg); 
            transform-origin: center center; transform-style: preserve-3d;
        }

        footer { 
            flex-shrink: 0; height: calc(80px + env(safe-area-inset-bottom)); 
            padding: 5px 10px; padding-bottom: max(5px, env(safe-area-inset-bottom));
            display: flex; justify-content: space-between; align-items: center; z-index: 100;
            box-shadow: 0 -8px 20px rgba(0,0,0,0.2);
            border-top-left-radius: 25px; border-top-right-radius: 25px; margin: 5px 10px 0 10px;
        }

        .footer-btns { display: flex; flex: 1; justify-content: space-around; margin-right: 10px; }
        
        .btn {
            background: linear-gradient(to bottom, var(--btn-yellow-1), var(--btn-yellow-2)); 
            border: 3px solid #ffffff; padding: 0; width: auto; flex: 1; margin: 0 3px;
            height: 44px; border-radius: 25px; font-weight: bold; font-size: 16px; 
            box-shadow: 0 5px 0 #ff8f00, 0 10px 20px rgba(0,0,0,0.2); 
            cursor: pointer; display: flex; justify-content: center; align-items: center; color: #5d4037;
            transition: all 0.1s; text-shadow: none;
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #ff8f00, 0 5px 10px rgba(0,0,0,0.2); }
        
        .btn-blue { 
            background: linear-gradient(to bottom, var(--btn-blue-1), var(--btn-blue-2)); 
            box-shadow: 0 5px 0 #01579b, 0 10px 20px rgba(0,0,0,0.2); color: white; 
        }
        .btn-blue:active { transform: translateY(3px); box-shadow: 0 2px 0 #01579b, 0 5px 10px rgba(0,0,0,0.2); }

        .btn-orange {
            background: linear-gradient(to bottom, #ffcc80, #ff9800);
            box-shadow: 0 5px 0 #e65100, 0 10px 20px rgba(0,0,0,0.2); color: #3e2723;
        }
        .btn-orange:active { transform: translateY(3px); box-shadow: 0 2px 0 #e65100, 0 5px 10px rgba(0,0,0,0.2); }

        #joystick-zone {
            position: relative; width: 60px; height: 60px; z-index: 150; flex-shrink: 0;
            background: rgba(255, 255, 255, 0.2) !important; 
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%; touch-action: none; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2), inset 0 2px 5px rgba(255,255,255,0.3);
        }
        #joystick-knob {
            width: 28px; height: 28px; background: radial-gradient(circle at 30% 30%, #ffcc80, #ff9800); 
            border-radius: 50%; border: 2px solid #fff; box-shadow: 0 5px 10px rgba(0,0,0,0.3); position: relative;
        }
        #joystick-hint {
            position: absolute; bottom: -15px; width: 100%; text-align: center;
            font-size: 9px; color: rgba(255, 255, 255, 0.9); pointer-events: none; font-weight: bold;
             text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* È∫ªÈõÄÁâå */
        .tile {
            position: absolute; width: var(--tile-w); height: var(--tile-h);
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px) saturate(120%); -webkit-backdrop-filter: blur(8px) saturate(120%);
            border-radius: 8px; cursor: pointer;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transform-style: preserve-3d; transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border-top: 1px solid rgba(255, 255, 255, 1.0);
            border-left: 1px solid rgba(255, 255, 255, 0.9);
            border-bottom: 1px solid rgba(200, 230, 255, 0.6);
            border-right: 1px solid rgba(200, 230, 255, 0.6);
            box-shadow: 0 2px 4px rgba(0, 50, 100, 0.3), 0 8px 20px rgba(0, 50, 100, 0.2);
        }

        .tile::before {
            content: ''; position: absolute; width: 100%; height: var(--depth);
            bottom: 0; left: 0;
            background: linear-gradient(to bottom, rgba(240, 250, 255, 0.7), rgba(180, 220, 240, 0.85));
            transform-origin: bottom; transform: rotateX(-90deg);
            border-radius: 0 0 8px 8px;
            border: 1px solid rgba(220, 240, 255, 0.6); border-top: none;
        }
        .tile::after {
            content: ''; position: absolute; width: var(--depth); height: 100%;
            top: 0; right: 0;
            background: linear-gradient(to right, rgba(240, 250, 255, 0.7), rgba(200, 230, 250, 0.8));
            transform-origin: right; transform: rotateY(90deg);
            border-radius: 0 8px 8px 0;
            border: 1px solid rgba(220, 240, 255, 0.6); border-left: none;
        }

        .tile.locked { 
            background-color: rgba(220, 230, 240, 0.9);
            filter: grayscale(60%) brightness(0.9);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        .tile.locked img, .tile.locked .t-icon { opacity: 0.3; }

        .tile.selected { 
            background-color: #fffde7; 
            transform: translateZ(calc(var(--base-z) + 30px)) scale(1.08) !important; 
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.9), 0 30px 60px rgba(0, 50, 100, 0.4);
            border: 2px solid #ffca28; z-index: 9999 !important;
        }

        .t-suit { position: absolute; top: 2px; right: 4px; font-size: 10px; color: #777; line-height: 1; backface-visibility: hidden; font-weight: bold; }
        .t-icon { font-size: 28px; line-height: 1; margin-top: 2px; backface-visibility: hidden; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2)); }
        .t-text { font-size: 11px; font-weight: 900; margin-top: 0px; color: #333; backface-visibility: hidden; text-shadow: 0 1px 0 rgba(255,255,255,1); }
        
        .c-red { color: #d32f2f; } .c-blue { color: #1565c0; } .c-green { color: #2e7d32; }

        #msg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 50, 100, 0.4); 
            display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center; padding: 20px;
            backdrop-filter: blur(15px);
        }
        .overlay-box {
            background: rgba(255, 255, 255, 0.9); padding: 30px; border-radius: 30px;
            box-shadow: 0 30px 80px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.7);
            max-width: 90%; color: #333;
        }
        .overlay-title { font-size: 36px; font-weight: bold; margin-bottom: 20px; color: #ffb300; text-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .overlay-verse { 
            font-size: 22px; color: #0288d1; line-height: 1.6; 
            background: rgba(224, 242, 241, 0.8); padding: 20px; border-radius: 20px; 
            width: 100%; margin-bottom: 20px; border: 1px solid rgba(178, 223, 219, 0.8);
            font-weight: bold; 
        }

        #watermark {
            position: absolute; bottom: 95px; left: 20px; font-size: 11px;
            color: rgba(255, 255, 255, 0.6); pointer-events: none; z-index: 150; font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

<header>
    <select id="map-select" onchange="changeMap(this.value)">
        <option value="random">üé≤ ÁÑ°ÈôêÈö®Ê©ü</option>
        <option value="turtle">üê¢ Á∂ìÂÖ∏ÈæúËÉå</option>
        <option value="castle">üè∞ Â†ÖÂõ∫Â†°Â£ò</option>
        <option value="cross">‚úùÔ∏è Ê¶ÆËÄÄÂçÅÊû∂</option>
        <option value="bridge">üåâ ÊÅ©ÂÖ∏‰πãÊ©ã</option>
        <option value="towers">üóº ÈõôÂ≠êÂ°î</option>
    </select>
    <div id="status">Ââ©È§ò: 0</div>
</header>

<div id="game-viewport">
    <div id="game-board"></div>
</div>

<footer>
    <div class="footer-btns">
        <button class="btn btn-blue" onclick="forceNewGame()">üîÑ Êñ∞Â±Ä</button>
        <button class="btn btn-orange" onclick="undoMove()">‚Ü©Ô∏è Âæ©Âéü</button>
        <button class="btn" onclick="autoHint()">üí° ÊèêÁ§∫</button>
    </div>
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
        <div id="joystick-hint">Ë¶ñËßí</div>
    </div>
</footer>

<div id="watermark">Powered by Google Gemini v35.1 (Debugged)</div>

<div id="msg-overlay">
    <div class="overlay-box">
        <div id="overlay-title" class="overlay-title"></div>
        <div id="overlay-verse" class="overlay-verse"></div>
        <button id="overlay-btn" class="btn" style="width: 220px; height: 50px; font-size: 20px;" onclick="forceNewGame()">ÊåëÊà∞‰∏ã‰∏ÄÈóú</button>
    </div>
</div>

<script>
    const rawTiles = [
        {t:"Êë©Ë•ø", i:"üåä", s:"Ëê¨", c:"c-red"}, {t:"Â§ßË°õ", i:"üëë", s:"Ëê¨", c:"c-red"},
        {t:"‰øùÁæÖ", i:"üìú", s:"Ëê¨", c:"c-red"}, {t:"ÂΩºÂæó", i:"üêü", s:"Ëê¨", c:"c-red"},
        {t:"Á¥ÑÊãø", i:"üêã", s:"Ëê¨", c:"c-red"}, {t:"È¶¨Âà©‰∫û", i:"ü§∞", s:"Ëê¨", c:"c-red"},
        {t:"‰∫û‰ºØËò≠", i:"üêë", s:"Ëê¨", c:"c-red"}, {t:"‰ΩÜ‰ª•ÁêÜ", i:"ü¶Å", s:"Ëê¨", c:"c-red"},
        {t:"ÊïôÊúÉ", i:"‚õ™", s:"Á≠í", c:"c-blue"}, {t:"Ë•øÂ•à", i:"‚õ∞Ô∏è", s:"Á≠í", c:"c-blue"},
        {t:"Á¥ÖÊµ∑", i:"üåä", s:"Á≠í", c:"c-blue"}, {t:"‰ºäÁî∏", i:"üçé", s:"Á≠í", c:"c-blue"},
        {t:"Âä†Âà©Âà©", i:"üõ∂", s:"Á≠í", c:"c-blue"}, {t:"ËÅñÊÆø", i:"üèõÔ∏è", s:"Á≠í", c:"c-blue"},
        {t:"ËÄ∂Âà©Âì•", i:"üß±", s:"Á≠í", c:"c-blue"}, {t:"ÊñπËàü", i:"üö¢", s:"Á≠í", c:"c-blue"},
        {t:"ÂçÅÊû∂", i:"‚úùÔ∏è", s:"Á¥¢", c:"c-green"}, {t:"ËÅñÁ∂ì", i:"üìñ", s:"Á¥¢", c:"c-green"},
        {t:"‰∫îÈ§Ö", i:"üçû", s:"Á¥¢", c:"c-green"}, {t:"‰∫åÈ≠ö", i:"üêü", s:"Á¥¢", c:"c-green"},
        {t:"ÂØ∂Ë°Ä", i:"üç∑", s:"Á¥¢", c:"c-green"}, {t:"ËÅñÈùà", i:"üïäÔ∏è", s:"Á¥¢", c:"c-green"},
        {t:"‰ø°", i:"üõ°Ô∏è", s:"Áï™", c:"#333"}, {t:"Êúõ", i:"‚öì", s:"Áï™", c:"#333"},
        {t:"ÊÑõ", i:"‚ù§Ô∏è", s:"Áï™", c:"#333"}, {t:"ÈòøÂÄë", i:"üôè", s:"Áï™", c:"#333"},
        {t:"Á¶±Âëä", i:"ü§≤", s:"Áï™", c:"#333"}, {t:"Âæ©Ê¥ª", i:"üåÖ", s:"Áï™", c:"#333"},
        {t:"Êå™‰∫û", i:"üåà", s:"Ëê¨", c:"c-red"}, {t:"Á¥ÑÊõ∏‰∫û", i:"üé∫", s:"Ëê¨", c:"c-red"},
        {t:"‰ª•Âà©‰∫û", i:"üî•", s:"Ëê¨", c:"c-red"}, 
        {t:"Ëë°ËêÑ", i:"üçá", s:"Á¥¢", c:"c-green"}, {t:"Á£êÁü≥", i:"ü™®", s:"Á¥¢", c:"c-green"},
        {t:"‰∫ÆÂÖâ", i:"üí°", s:"Á≠í", c:"c-blue"}, {t:"Â§©Âúã", i:"‚òÅÔ∏è", s:"Á≠í", c:"c-blue"},
        {t:"ÂñúÊ®Ç", i:"üòÑ", s:"Áï™", c:"#333"}
    ];
    
    const winVerses = ["ÊµÅÊ∑öÊííÁ®ÆÁöÑÔºåÂøÖÊ≠°ÂëºÊî∂Ââ≤„ÄÇ(Ë©© 126:5)", "ÈÇ£ÁæéÂ•ΩÁöÑ‰ªóÊàëÂ∑≤Á∂ìÊâìÈÅé‰∫Ü„ÄÇ(ÊèêÂæå 4:7)", "Èù†ËëóÈÇ£Âä†Áµ¶ÊàëÂäõÈáèÁöÑÔºåÂá°‰∫ãÈÉΩËÉΩÂÅö„ÄÇ(ËÖì 4:13)", "‰Ω†ÂÄëÊòØ‰∏ñ‰∏äÁöÑÂÖâ„ÄÇ(Â§™ 5:14)", "ÂæóÂãùÁöÑÔºåÊàëË¶ÅË≥ú‰ªñÂú®ÊàëÂØ∂Â∫ß‰∏äËàáÊàëÂêåÂùê„ÄÇ(Âïü 3:21)"];
    const loseVerses = ["ÊàëÁöÑÊÅ©ÂÖ∏ÊòØÂ§†‰Ω†Áî®ÁöÑ„ÄÇ(ÊûóÂæå 12:9)", "ÊáâÁï∂‰∏ÄÁÑ°ÊéõÊÖÆÔºåÂè™Ë¶ÅÂá°‰∫ãËóâËëóÁ¶±Âëä„ÄÇ(ËÖì 4:6)", "‰Ω†ÂÄëË¶Å‰ºëÊÅØÔºåË¶ÅÁü•ÈÅìÊàëÊòØÁ•û„ÄÇ(Ë©© 46:10)", "Ëê¨‰∫ãÈÉΩ‰∫íÁõ∏ÊïàÂäõ„ÄÇ(ÁæÖ 8:28)"];

    const MapBlueprints = {
        turtle: () => generatePyramid(6, 8, [6,6, 4,4, 2,2, 1,1]), 
        castle: () => generateWall(6, 8),
        cross: () => generateCross(),
        bridge: () => generateBridge(),
        towers: () => generateTowers(),
        random: () => generateChaos()
    };
    function generatePyramid(rows, cols, layerSizes) { let slots=[]; let cl=0; for(let i=0;i<layerSizes.length;i+=2){ let h=layerSizes[i], w=layerSizes[i+1]; let sr=Math.floor((rows-h)/2), sc=Math.floor((cols-w)/2); for(let r=0;r<h;r++) for(let c=0;c<w;c++) slots.push([cl, sr+r, sc+c]); cl++; } return slots; }
    function generateWall(rows, cols) { let slots=[]; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) { slots.push([0, r, c]); if(r===0||r===rows-1||c===0||c===cols-1) slots.push([1, r, c]); } return slots; }
    function generateCross() { let slots=[]; for(let r=0;r<8;r++) { slots.push([0,r,3]); slots.push([0,r,4]); slots.push([1,r,3]); } for(let c=0;c<8;c++) { slots.push([0,2,c]); slots.push([0,3,c]); slots.push([1,2,c]); } slots.push([2,2,3]); slots.push([2,3,3]); return slots; }
    function generateBridge() { let slots=[]; for(let c=0;c<10;c++) { slots.push([0,2,c]); slots.push([0,3,c]); if(c<3||c>6) { slots.push([1,2,c]); slots.push([1,3,c]); slots.push([2,2,c]); } } return slots; }
    function generateTowers() { let slots=[]; for(let r=0;r<6;r++) for(let c=0;c<8;c++) { if(c<2||c>5) { slots.push([0,r,c]); slots.push([1,r,c]); if(r>1&&r<4) slots.push([2,r,c]); } else if(r===2||r===3) slots.push([0,r,c]); } return slots; }
    
    // v35.1 ‰øÆÂæ©ÔºöÈò≤Ê≠¢Â∫ßÊ®ôÈáçÁñäÁöÑÈö®Ê©üÁîüÊàê
    function generateChaos() { 
        let slots=[]; 
        let occupied = new Set(); // Ë®òÈåÑÂ∑≤‰ΩîÁî®ÁöÑ‰ΩçÁΩÆ (z,r,c)

        // Â∫ïÂ±§ (Á¢∫‰øù‰∏çÈáçÁñä)
        for(let r=0;r<6;r++) for(let c=0;c<8;c++) {
            slots.push([0,r,c]);
            occupied.add(`0,${r},${c}`);
        }
        
        // Èö®Ê©üÂ±§
        let added = 0;
        while(added < 32) {
            let z = Math.floor(Math.random()*2)+1;
            let r = Math.floor(Math.random()*4)+1;
            let c = Math.floor(Math.random()*6)+1;
            let key = `${z},${r},${c}`;
            
            if(!occupied.has(key)) {
                slots.push([z,r,c]);
                occupied.add(key);
                added++;
            }
        }
        return slots; 
    }

    let tiles = [];
    let selectedTile = null;
    let moveHistory = [];
    let tileW = 44, tileH = 58; 
    let globalScale = 1;
    let viewRotX = 30;
    let viewRotZ = 0;

    function changeMap(val) { startGame(val); }
    function forceNewGame() { startGame(document.getElementById('map-select').value); }

    function startGame(mapType) {
        document.getElementById('msg-overlay').style.display = 'none';
        const board = document.getElementById('game-board');
        board.innerHTML = ''; tiles = []; selectedTile = null; 
        moveHistory = []; 
        viewRotX = 30; viewRotZ = 0; 

        // v35.1 Ê†∏ÂøÉ‰øÆÂæ©Ôºö‰øùË≠âÊúâËß£Âæ™Áí∞
        // Â¶ÇÊûúÈö®Ê©üÁîüÊàêÁöÑÂú∞ÂúñÁÑ°Ê≥ïÊâæÂà∞Ëß£ÔºåÂ∞±ÈáçÊñ∞ÁîüÊàêÂú∞ÂúñÔºåÁõ¥Âà∞ÊâæÂà∞ÁÇ∫Ê≠¢
        let solvableMapFound = false;
        let attemptMap = 0;
        
        while (!solvableMapFound && attemptMap < 50) {
            let slots = MapBlueprints[mapType]();
            
            // Á¢∫‰øùÂÅ∂Êï∏Âºµ
            if(slots.length % 2 !== 0) slots.pop();
            
            let minC = Infinity, minR = Infinity;
            slots.forEach(s => { if(s[1]<minR) minR=s[1]; if(s[2]<minC) minC=s[2]; });
            slots.forEach(s => { s[1]-=minR; s[2]-=minC; });

            let virtualTiles = slots.map((s, i) => ({ id: i, z: s[0], r: s[1], c: s[2], active: true }));
            
            // ÂòóË©¶Ëß£ÈÄôÂÄãÂú∞Âúñ
            let pairs = [], tempTiles, success = false, attemptSolve = 0;
            
            // Ê®°Êì¨Ëß£Áâå (ÊúÄÂ§öË©¶ 20 Ê¨°‰∏çÂêåË∑ØÂæë)
            while(!success && attemptSolve < 20) {
                tempTiles = JSON.parse(JSON.stringify(virtualTiles)); pairs = []; let possible = true;
                while(tempTiles.some(t => t.active)) {
                    let available = getAvailableTiles(tempTiles);
                    if(available.length < 2) { possible = false; break; }
                    let t1 = available.splice(Math.floor(Math.random()*available.length), 1)[0];
                    let t2 = available.splice(Math.floor(Math.random()*available.length), 1)[0];
                    pairs.push([t1.id, t2.id]); 
                    // Ê®ôË®òÁÇ∫Â∑≤Ê∂àÈô§
                    tempTiles.find(t=>t.id===t1.id).active = false;
                    tempTiles.find(t=>t.id===t2.id).active = false;
                }
                if(possible) success = true; 
                attemptSolve++;
            }

            if(success) {
                // ÊâæÂà∞‰∫ÜÊúâËß£ÁöÑÂú∞ÂúñÔºÅÊáâÁî®ÂÆÉ
                solvableMapFound = true;
                applyGame(virtualTiles, pairs);
            } else {
                // Âè™Âú®Èö®Ê©üÊ®°Âºè‰∏ãÈáçË©¶Âú∞ÂúñÔºåÂõ∫ÂÆöÂú∞ÂúñÂâá‰øùÂ∫ï
                if(mapType !== 'random') {
                    solvableMapFound = true; // Âº∑Ë°åÈñãÂßãÔºåÊúÉÊúâÊ≠ªÂ±ÄÈ¢®Èö™‰ΩÜÊ≤íËæ¶Ê≥ï
                    let backupPairs = [];
                    for(let i=0; i<virtualTiles.length; i+=2) backupPairs.push([i, i+1]);
                    applyGame(virtualTiles, backupPairs);
                }
                attemptMap++;
            }
        }
        
        if(!solvableMapFound) alert("ÁîüÊàêÂú∞ÂúñÂ§±ÊïóÔºåË´ãÈáçË©¶");
    }

    function applyGame(virtualTiles, pairs) {
        let totalPairs = pairs.length, cardInventory = [], shuffledTypes = [...rawTiles].sort(()=>Math.random()-0.5);
        let typeIndex = 0;
        
        // ‰øÆÊ≠£ÔºöÁ¢∫‰øù cardInventory Êï∏ÈáèÊ≠£Á¢∫
        for(let i=0; i<totalPairs; i++) { // Ê≥®ÊÑèÔºöÈÄôË£°ÊòØ i++ ‰∏çÊòØ i+=2
            let card = shuffledTypes[typeIndex % shuffledTypes.length];
            cardInventory.push(card); 
            typeIndex++;
        }
        // ‰∏çÈúÄË¶ÅÈÄôË£°ÂÜç shuffle cardInventoryÔºåÂõ†ÁÇ∫ shuffledTypes Â∑≤Á∂ì‰∫Ç‰∫ÜÔºå
        // ‰∏î pairs ÊòØÈö®Ê©üÁîüÊàêÁöÑËß£Ê≥ïÔºåÊâÄ‰ª•Áõ¥Êé•ÊåâÈ†ÜÂ∫èÂàÜÈÖçÁµ¶ pairs Âç≥ÂèØ‰øùË≠âÊúâËß£„ÄÇ
        
        let finalTilesData = new Array(virtualTiles.length);
        pairs.forEach((pair, idx) => { 
            finalTilesData[pair[0]] = cardInventory[idx]; 
            finalTilesData[pair[1]] = cardInventory[idx]; 
        });

        renderTiles(virtualTiles, finalTilesData);
        setTimeout(fitBoard, 50);
        updateStatusText();
    }

    function getAvailableTiles(tileSet) { return tileSet.filter(t => t.active && !checkLockedInSet(t, tileSet)); }
    function checkLockedInSet(tile, tileSet) {
        let hasTop=false, hasLeft=false, hasRight=false;
        for(let other of tileSet) {
            if(!other.active || other.id === tile.id) continue;
            if(other.z === tile.z+1 && other.r === tile.r && other.c === tile.c) hasTop = true;
            if(other.z === tile.z && other.r === tile.r) { if(other.c === tile.c-1) hasLeft=true; if(other.c === tile.c+1) hasRight=true; }
        }
        return hasTop || (hasLeft && hasRight);
    }

    function renderTiles(slots, dataMap) {
        const board = document.getElementById('game-board');
        let maxX=0, maxY=0;
        slots.forEach((slot, index) => {
            if(slot.c > maxX) maxX = slot.c; if(slot.r > maxY) maxY = slot.r;
            const el = document.createElement('div');
            el.className = 'tile';
            
            const card = dataMap[index];
            el.innerHTML = `<div class="t-suit">${card.s}</div><div class="t-icon ${card.c}">${card.i}</div><div class="t-text ${card.c}">${card.t}</div>`;
            
            let left = slot.c * tileW; 
            let top = slot.r * tileH; 
            let zHeight = slot.z * 12; 
            
            el.style.left = left + 'px'; 
            el.style.top = top + 'px'; 
            el.style.transform = `translateZ(${zHeight}px)`; 
            el.style.setProperty('--base-z', zHeight + 'px');
            el.style.zIndex = slot.z * 10 + slot.r; 
            
            const tileObj = { el: el, data: card, z: slot.z, r: slot.r, c: slot.c, active: true, id: index };
            el.onclick = () => onTileClick(tileObj);
            board.appendChild(el);
            tiles.push(tileObj);
        });
        board.style.width = (maxX + 1) * tileW + 'px';
        board.style.height = (maxY + 1) * tileH + 'px';
        updateLockStatus();
    }

    function updateLockStatus() { tiles.forEach(t => { if(!t.active) return; t.isLocked = checkLocked(t); t.el.classList.toggle('locked', t.isLocked); }); }
    
    function checkLocked(tile) {
        let hasTop=false, hasLeft=false, hasRight=false;
        for(let other of tiles) {
            if(!other.active || other === tile) continue;
            if(other.z === tile.z+1 && other.r === tile.r && other.c === tile.c) hasTop = true;
            if(other.z === tile.z && other.r === tile.r) { if(other.c === tile.c-1) hasLeft=true; if(other.c === tile.c+1) hasRight=true; }
        }
        return hasTop || (hasLeft && hasRight);
    }

    function onTileClick(tile) {
        if(!tile.active || tile.isLocked) return;
        if(selectedTile === tile) { tile.el.classList.remove('selected'); selectedTile = null; }
        else if(selectedTile) {
            if(tile.data.t === selectedTile.data.t) {
                moveHistory.push([tile, selectedTile]);
                tile.active=false; selectedTile.active=false;
                tile.el.style.display='none'; selectedTile.el.style.display='none'; 
                selectedTile = null;
                updateLockStatus(); updateStatusText(); checkGameState();
            } else { selectedTile.el.classList.remove('selected'); selectedTile = tile; tile.el.classList.add('selected'); }
        } else { selectedTile = tile; tile.el.classList.add('selected'); }
    }

    function undoMove() {
        if (moveHistory.length === 0) return; 
        const lastMove = moveHistory.pop();
        const tile1 = lastMove[0]; const tile2 = lastMove[1];
        tile1.active = true; tile2.active = true;
        tile1.el.style.display = ''; tile2.el.style.display = '';
        tile1.el.classList.remove('selected'); tile2.el.classList.remove('selected');
        if(selectedTile) { selectedTile.el.classList.remove('selected'); selectedTile = null; }
        updateLockStatus(); updateStatusText();
    }

    function checkGameState() { if(tiles.filter(t=>t.active).length===0) showModal('win'); else if(!hasAvailableMoves()) showModal('lose'); }
    function hasAvailableMoves() {
        let free = tiles.filter(t=>t.active && !t.isLocked);
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) return true;
        return false;
    }

    function showModal(type) {
        const overlay = document.getElementById('msg-overlay'), title = document.getElementById('overlay-title'), verse = document.getElementById('overlay-verse'), btn = document.getElementById('overlay-btn');
        if(type==='win') {
            title.innerText="üéâ ÂìàÂà©Ë∑Ø‰∫ûÔºÅ(ÂãùÂà©)"; title.style.color="#ffb300"; verse.innerText=winVerses[Math.floor(Math.random()*winVerses.length)];
            btn.innerText="ÊåëÊà∞‰∏ã‰∏ÄÈóú üöÄ"; btn.onclick=()=>{ document.getElementById('map-select').value=['random','turtle','castle','cross','bridge','towers'][Math.floor(Math.random()*6)]; startGame(document.getElementById('map-select').value); };
            btn.className = "btn"; 
        } else {
            title.innerText="üí™ ÊÅ©ÂÖ∏Â§†Áî® (Êö´ÊôÇÁÑ°Ë∑Ø)"; title.style.color="#4fc3f7"; verse.innerText=loseVerses[Math.floor(Math.random()*loseVerses.length)];
            btn.innerText="ÈáçÊñ∞ÈñãÂßã üîÑ"; btn.onclick=()=>forceNewGame();
            btn.className = "btn btn-blue"; 
        }
        overlay.style.display='flex';
    }

    function autoHint() {
        let free=tiles.filter(t=>t.active && !t.isLocked);
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) {
            free[i].el.style.background='#b3e5fc'; free[j].el.style.background='#b3e5fc';
            setTimeout(()=>{ free[i].el.style.background=''; free[j].el.style.background=''; }, 1500); return;
        }
        alert("ÁõÆÂâçÁÑ°Ëß£ÔºåË´ãÊåâ„ÄåÊ¥óÁâå„ÄçÔºÅ"); // ÊèêÁ§∫Ê¥óÁâåÔºå‰ΩÜÂØ¶ÈöõÂ∑≤ÁÑ°ÊåâÈàï
    }
    
    function shuffleActiveTiles() {
        let active=tiles.filter(t=>t.active), datas=active.map(t=>t.data), attempt=0, solvable=false;
        let freeIndices=active.map((t,i)=>!checkLocked(t)?i:-1).filter(i=>i!==-1);
        while(!solvable && attempt<50) {
            datas.sort(()=>Math.random()-0.5); let seen=new Set();
            for(let i of freeIndices) { if(seen.has(datas[i].t)) { solvable=true; break; } seen.add(datas[i].t); }
            attempt++;
        }
        active.forEach((t,i)=>{ t.data=datas[i]; t.el.classList.remove('selected'); t.el.innerHTML=`<div class="t-suit">${t.data.s}</div><div class="t-icon ${t.data.c}">${t.data.i}</div><div class="t-text ${t.data.c}">${t.data.t}</div>`; });
        selectedTile=null; document.getElementById('game-board').style.opacity=0.5; setTimeout(()=>document.getElementById('game-board').style.opacity=1, 300);
        moveHistory = [];
    }

    function updateStatusText() { document.getElementById('status').innerText = "Ââ©È§ò: " + tiles.filter(t => t.active).length; }

    function applyViewTransform() {
        const board = document.getElementById('game-board');
        if(!board) return;
        board.style.transform = `translate(-50%, -50%) rotateX(${viewRotX}deg) rotateZ(${viewRotZ}deg) scale(${globalScale})`;
    }

    function fitBoard() {
        const board = document.getElementById('game-board');
        const view = document.getElementById('game-viewport');
        if(!board || !view) return;
        board.style.transform = 'none';
        const boardW = board.scrollWidth; const boardH = board.scrollHeight;
        const viewW = view.clientWidth; const viewH = view.clientHeight;
        globalScale = Math.min((viewW - 40) / boardW, (viewH - 40) / boardH);
        applyViewTransform();
    }
    window.addEventListener('resize', fitBoard);

    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');
    let isDragging = false;
    let startX, startY;
    let initialRotX, initialRotZ;

    function handleStart(e) {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
        initialRotX = viewRotX; initialRotZ = viewRotZ;
        joystickKnob.style.transition = 'none';
    }

    function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault(); 
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        const maxDist = 30;
        const dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
        const limitedDist = Math.min(dist, maxDist);
        const angle = Math.atan2(deltaY, deltaX);
        const knobX = Math.cos(angle) * limitedDist;
        const knobY = Math.sin(angle) * limitedDist;
        joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
        viewRotZ = initialRotZ + (deltaX * 0.5); 
        viewRotX = initialRotX - (deltaY * 0.5); 
        viewRotX = Math.max(0, Math.min(viewRotX, 60)); 
        applyViewTransform();
    }

    function handleEnd() {
        isDragging = false;
        joystickKnob.style.transition = 'transform 0.2s';
        joystickKnob.style.transform = 'translate(0, 0)';
    }

    joystickZone.addEventListener('mousedown', handleStart);
    joystickZone.addEventListener('touchstart', handleStart, {passive: false});
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('touchmove', handleMove, {passive: false});
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('touchend', handleEnd);

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('./sw.js')
                .then(function(registration) { console.log('SW OK'); }, function(err) { console.log('SW Fail'); });
        });
    }

    startGame('random'); 
</script>
</body>
</html>
