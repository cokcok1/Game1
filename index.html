<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-title" content="ç¦éŸ³éº»é›€">
    <meta name="application-name" content="ç¦éŸ³éº»é›€">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <link rel="apple-touch-icon" href="https://cokcok1.github.io/Game1/mj.png">
    <link rel="icon" type="image/png" href="https://cokcok1.github.io/Game1/mj.png">

    <title>ç¦éŸ³éº»é›€ - v15</title>
    <style>
        :root { 
            --tile-w: 42px; 
            --tile-h: 56px; 
            --depth-x: 3px; /* å´é¢åšåº¦ */
            --depth-y: 6px; /* åº•éƒ¨åšåº¦ */
        }
        
        * { box-sizing: border-box; }

        body {
            margin: 0; background-color: #054a29; 
            background-image: repeating-linear-gradient(45deg, #065f35 0, #065f35 1px, #054a29 0, #054a29 5px);
            font-family: "Microsoft JhengHei", sans-serif;
            overflow: hidden; display: flex; flex-direction: column; height: 100vh; height: 100dvh; 
            color: white; user-select: none; -webkit-user-select: none; touch-action: none;
        }
        
        /* é ‚éƒ¨ (iPad é©é…) */
        header {
            flex-shrink: 0; 
            height: calc(44px + env(safe-area-inset-top)); 
            padding: 0 10px; 
            padding-top: env(safe-area-inset-top); 
            background: rgba(0,0,0,0.85); 
            display: flex; justify-content: space-between; align-items: center; z-index: 100; font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        select { padding: 4px; font-size: 14px; border-radius: 5px; border: 1px solid #999; background: #eee; max-width: 140px; }
        #status { font-size: 14px; font-weight: bold; background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 12px; }
        
        /* --- 3D è¦–è§’æ ¸å¿ƒè¨­å®š --- */
        #game-viewport {
            flex: 1; width: 100%; position: relative; overflow: hidden; padding: 0;
            /* 1. å®šç¾©é€è¦–é»ï¼Œæ•¸å€¼è¶Šå°ï¼Œé€è¦–æ„Ÿè¶Šå¼· */
            perspective: 1000px; 
            /* 2. è¨­å®šè¦–è§’ä¸­å¿ƒï¼Œé€™è£¡è¨­ç‚ºç•«é¢ä¸­å¿ƒ */
            perspective-origin: center center;
        }

        #game-board { 
            position: absolute; 
            top: 50%; left: 50%; 
            /* 3. æ‡‰ç”¨ 3D æ—‹è½‰ï¼šæ²¿ X è»¸å‚¾æ–œï¼Œæ²¿ Z è»¸è¼•å¾®æ—‹è½‰ */
            transform: translate(-50%, -50%) rotateX(20deg) rotateZ(-5deg); 
            transform-origin: center center;
            /* 4. ç¢ºä¿å­å…ƒç´ ä¿æŒ 3D ç©ºé–“é—œä¿‚ */
            transform-style: preserve-3d;
            transition: transform 0.1s linear; 
        }

        /* åº•éƒ¨ (iPad é©é…) */
        footer { 
            flex-shrink: 0; height: calc(54px + env(safe-area-inset-bottom)); 
            padding: 5px; 
            padding-bottom: max(5px, env(safe-area-inset-bottom));
            background: rgba(0,0,0,0.85); 
            display: flex; justify-content: space-around; align-items: flex-start;
            padding-top: 10px;
            z-index: 100;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .btn {
            background: linear-gradient(to bottom, #FFD700, #FFA000); border: none; padding: 0;
            width: 32%; height: 38px; border-radius: 19px; font-weight: bold; font-size: 15px; 
            box-shadow: 0 3px 0 #b8860b; cursor: pointer; display: flex; justify-content: center; 
            align-items: center; color: #333;
        }
        .btn:active { transform: translateY(2px); box-shadow: none; }
        .btn-blue { background: linear-gradient(to bottom, #4FC3F7, #039BE5); box-shadow: 0 3px 0 #0277BD; color: white; }

        /* éº»é›€ç‰Œ - é…åˆ 3D çš„æ–°æ¨£å¼ */
        .tile {
            position: absolute; width: var(--tile-w); height: var(--tile-h);
            background: #fff; 
            border-radius: 4px; 
            cursor: pointer;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: all 0.1s;
            /* ç¢ºä¿åœ¨ 3D ç©ºé–“ä¸­æ­£ç¢ºæ¸²æŸ“ */
            transform-style: preserve-3d;
            
            /* å¯¦é«”æ„Ÿï¼šå´é¢å’Œåº•éƒ¨ */
            border-right: var(--depth-x) solid #d0d0d0; /* å´é¢ç°è‰² */
            border-bottom: var(--depth-y) solid #b0b0b0; /* åº•éƒ¨æ·±ç° */
            border-top: 1px solid #fff;
            border-left: 1px solid #fff;
            
            /* é…åˆæ–°è¦–è§’çš„é™°å½±ï¼šå‘å³ä¸‹æ–¹æŠ•å°„ */
            box-shadow: 4px 4px 8px rgba(0,0,0,0.3);
        }

        /* ä¸åŒå±¤ç´šçš„é™°å½±æ•ˆæœï¼Œå¢å¼·å±¤æ¬¡æ„Ÿ */
        .tile[data-layer="0"] { box-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .tile[data-layer="1"] { box-shadow: 4px 4px 8px rgba(0,0,0,0.3); }
        .tile[data-layer="2"] { box-shadow: 6px 6px 12px rgba(0,0,0,0.35); }
        .tile[data-layer="3"] { box-shadow: 8px 8px 16px rgba(0,0,0,0.4); }
        .tile[data-layer="4"] { box-shadow: 10px 10px 20px rgba(0,0,0,0.45); }
        
        .t-suit { position: absolute; top: 1px; right: 2px; font-size: 10px; color: #888; line-height: 1; }
        .t-icon { font-size: 26px; line-height: 1; margin-top: 2px; }
        .t-text { font-size: 11px; font-weight: 900; margin-top: 0px; color: #333; }
        
        /* é–å®šç‹€æ…‹ */
        .tile.locked { filter: brightness(0.6); cursor: default; background: #ccc; box-shadow: none; border-color: #999; }
        
        /* é¸ä¸­ç‹€æ…‹ï¼šåœ¨ 3D ç©ºé–“ä¸­å‘ä¸Šæµ®èµ· */
        .tile.selected { 
            background: #fffbe6; 
            border-color: #ff9800; 
            /* åœ¨ Z è»¸ä¸Šç§»å‹•ï¼Œç”¢ç”Ÿæµ®èµ·æ•ˆæœ */
            transform: translateZ(10px); 
            z-index: 999 !important; 
            /* é¸ä¸­æ™‚é™°å½±åŠ æ·±åŠ å¤§ */
            box-shadow: 8px 8px 16px rgba(0,0,0,0.5) !important;
        }
        
        .c-red { color: #d32f2f; } .c-blue { color: #1976d2; } .c-green { color: #388e3c; }

        #msg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center; padding: 20px;
        }
        .overlay-title { font-size: 32px; font-weight: bold; margin-bottom: 20px; }
        .overlay-verse { 
            font-size: 20px; color: #fff; line-height: 1.5; 
            background: rgba(255,255,255,0.15); padding: 25px; border-radius: 15px; 
            width: 100%; max-width: 400px;
        }

        #watermark {
            position: absolute; bottom: 65px; right: 10px; font-size: 10px;
            color: rgba(255, 255, 255, 0.3); pointer-events: none; z-index: 150;
        }
    </style>
</head>
<body>

<header>
    <select id="map-select" onchange="changeMap(this.value)">
        <option value="random">ğŸ² ç„¡é™éš¨æ©Ÿ</option>
        <option value="turtle">ğŸ¢ ç¶“å…¸é¾œèƒŒ</option>
        <option value="castle">ğŸ° å …å›ºå ¡å£˜</option>
        <option value="cross">âœï¸ æ¦®è€€åæ¶</option>
        <option value="bridge">ğŸŒ‰ æ©å…¸ä¹‹æ©‹</option>
        <option value="towers">ğŸ—¼ é›™å­å¡”</option>
    </select>
    <div id="status">å‰©é¤˜: 0</div>
</header>

<div id="game-viewport">
    <div id="game-board"></div>
</div>

<footer>
    <button class="btn btn-blue" onclick="forceNewGame()">ğŸ”„ æ–°å±€</button>
    <button class="btn" onclick="shuffleActiveTiles()">ğŸ”€ æ´—ç‰Œ</button>
    <button class="btn" onclick="autoHint()">ğŸ’¡ æç¤º</button>
</footer>

<div id="watermark">Powered by Google Gemini v15</div>

<div id="msg-overlay">
    <div id="overlay-title" class="overlay-title" style="color:#FFD700;">å“ˆåˆ©è·¯äºï¼</div>
    <div id="overlay-verse" class="overlay-verse"></div>
    <button id="overlay-btn" class="btn" style="width: 220px; margin-top: 30px; height: 50px; font-size: 18px;" onclick="forceNewGame()">æŒ‘æˆ°ä¸‹ä¸€é—œ</button>
</div>

<script>
    const rawTiles = [
        {t:"æ‘©è¥¿", i:"ğŸŒŠ", s:"è¬", c:"c-red"}, {t:"å¤§è¡›", i:"ğŸ‘‘", s:"è¬", c:"c-red"},
        {t:"ä¿ç¾…", i:"ğŸ“œ", s:"è¬", c:"c-red"}, {t:"å½¼å¾—", i:"ğŸŸ", s:"è¬", c:"c-red"},
        {t:"ç´„æ‹¿", i:"ğŸ‹", s:"è¬", c:"c-red"}, {t:"é¦¬åˆ©äº", i:"ğŸ¤°", s:"è¬", c:"c-red"},
        {t:"äºä¼¯è˜­", i:"ğŸ‘", s:"è¬", c:"c-red"}, {t:"ä½†ä»¥ç†", i:"ğŸ¦", s:"è¬", c:"c-red"},
        {t:"æ•™æœƒ", i:"â›ª", s:"ç­’", c:"c-blue"}, {t:"è¥¿å¥ˆ", i:"â›°ï¸", s:"ç­’", c:"c-blue"},
        {t:"ç´…æµ·", i:"ğŸŒŠ", s:"ç­’", c:"c-blue"}, {t:"ä¼Šç”¸", i:"ğŸ", s:"ç­’", c:"c-blue"},
        {t:"åŠ åˆ©åˆ©", i:"ğŸ›¶", s:"ç­’", c:"c-blue"}, {t:"è–æ®¿", i:"ğŸ›ï¸", s:"ç­’", c:"c-blue"},
        {t:"è€¶åˆ©å“¥", i:"ğŸ§±", s:"ç­’", c:"c-blue"}, {t:"æ–¹èˆŸ", i:"ğŸš¢", s:"ç­’", c:"c-blue"},
        {t:"åæ¶", i:"âœï¸", s:"ç´¢", c:"c-green"}, {t:"è–ç¶“", i:"ğŸ“–", s:"ç´¢", c:"c-green"},
        {t:"äº”é¤…", i:"ğŸ", s:"ç´¢", c:"c-green"}, {t:"äºŒé­š", i:"ğŸŸ", s:"ç´¢", c:"c-green"},
        {t:"å¯¶è¡€", i:"ğŸ·", s:"ç´¢", c:"c-green"}, {t:"è–éˆ", i:"ğŸ•Šï¸", s:"ç´¢", c:"c-green"},
        {t:"ä¿¡", i:"ğŸ›¡ï¸", s:"ç•ª", c:"#333"}, {t:"æœ›", i:"âš“", s:"ç•ª", c:"#333"},
        {t:"æ„›", i:"â¤ï¸", s:"ç•ª", c:"#333"}, {t:"é˜¿å€‘", i:"ğŸ™", s:"ç•ª", c:"#333"},
        {t:"ç¦±å‘Š", i:"ğŸ¤²", s:"ç•ª", c:"#333"}, {t:"å¾©æ´»", i:"ğŸŒ…", s:"ç•ª", c:"#333"}
    ];
    
    const winVerses = [
        "æµæ·šæ’’ç¨®çš„ï¼Œå¿…æ­¡å‘¼æ”¶å‰²ã€‚(è©© 126:5)", "é‚£ç¾å¥½çš„ä»—æˆ‘å·²ç¶“æ‰“éäº†ã€‚(æå¾Œ 4:7)",
        "é è‘—é‚£åŠ çµ¦æˆ‘åŠ›é‡çš„ï¼Œå‡¡äº‹éƒ½èƒ½åšã€‚(è…“ 4:13)", "ä½ å€‘æ˜¯ä¸–ä¸Šçš„å…‰ã€‚(å¤ª 5:14)",
        "å¾—å‹çš„ï¼Œæˆ‘è¦è³œä»–åœ¨æˆ‘å¯¶åº§ä¸Šèˆ‡æˆ‘åŒåã€‚(å•Ÿ 3:21)"
    ];
    const loseVerses = [
        "æˆ‘çš„æ©å…¸æ˜¯å¤ ä½ ç”¨çš„ã€‚(æ—å¾Œ 12:9)", "æ‡‰ç•¶ä¸€ç„¡æ›æ…®ï¼Œåªè¦å‡¡äº‹è—‰è‘—ç¦±å‘Šã€‚(è…“ 4:6)",
        "ä½ å€‘è¦ä¼‘æ¯ï¼Œè¦çŸ¥é“æˆ‘æ˜¯ç¥ã€‚(è©© 46:10)", "è¬äº‹éƒ½äº’ç›¸æ•ˆåŠ›ã€‚(ç¾… 8:28)"
    ];

    const MapBlueprints = {
        turtle: () => generatePyramid(6, 8, [6,6, 4,4, 2,2, 1,1]), 
        castle: () => generateWall(6, 8),
        cross: () => generateCross(),
        bridge: () => generateBridge(),
        towers: () => generateTowers(),
        random: () => generateChaos()
    };
    
    function generatePyramid(rows, cols, layerSizes) {
        let slots = []; let currentLayer = 0;
        for(let i=0; i<layerSizes.length; i+=2) {
            let h = layerSizes[i], w = layerSizes[i+1];
            let startR = Math.floor((rows - h)/2), startC = Math.floor((cols - w)/2);
            for(let r=0; r<h; r++) for(let c=0; c<w; c++) slots.push([currentLayer, startR+r, startC+c]);
            currentLayer++;
        }
        return slots;
    }
    function generateWall(rows, cols) {
        let slots = [];
        for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
            slots.push([0, r, c]);
            if(r===0 || r===rows-1 || c===0 || c===cols-1) slots.push([1, r, c]); 
        }
        return slots;
    }
    function generateCross() {
        let slots = [];
        for(let r=0; r<8; r++) { slots.push([0, r, 3]); slots.push([0, r, 4]); slots.push([1, r, 3]); }
        for(let c=0; c<8; c++) { slots.push([0, 2, c]); slots.push([0, 3, c]); slots.push([1, 2, c]); }
        slots.push([2, 2, 3]); slots.push([2, 3, 3]);
        return slots;
    }
    function generateBridge() {
        let slots = [];
        for(let c=0; c<10; c++) {
            slots.push([0, 2, c]); slots.push([0, 3, c]);
            if(c<3 || c>6) { slots.push([1, 2, c]); slots.push([1, 3, c]); slots.push([2, 2, c]); }
        }
        return slots;
    }
    function generateTowers() {
        let slots = [];
        for(let r=0; r<6; r++) for(let c=0; c<8; c++) {
             if(c<2 || c>5) { slots.push([0, r, c]); slots.push([1, r, c]); if(r>1&&r<4) slots.push([2, r, c]); }
             else if(r===2 || r===3) slots.push([0, r, c]); 
        }
        return slots;
    }
    function generateChaos() {
        let slots = [];
        for(let r=0; r<6; r++) for(let c=0; c<8; c++) slots.push([0, r, c]); 
        for(let i=0; i<32; i++) {
            slots.push([Math.floor(Math.random()*2)+1, Math.floor(Math.random()*4)+1, Math.floor(Math.random()*6)+1]);
        }
        return slots;
    }

    let tiles = [];
    let selectedTile = null;
    let tileW = 42; 
    let tileH = 56;
    // é…åˆ 3D è¦–è§’çš„å±¤ç´šåç§»
    let offsetX = 0; 
    let offsetY = -8; 

    function changeMap(val) { startGame(val); }
    function forceNewGame() { startGame(document.getElementById('map-select').value); }

    function startGame(mapType) {
        document.getElementById('msg-overlay').style.display = 'none';
        const board = document.getElementById('game-board');
        board.innerHTML = '';
        tiles = [];
        selectedTile = null;

        let slots = MapBlueprints[mapType]();
        if(slots.length % 2 !== 0) slots.pop();
        
        let minC = Infinity, minR = Infinity;
        slots.forEach(s => { if(s[1]<minR) minR=s[1]; if(s[2]<minC) minC=s[2]; });
        slots.forEach(s => { s[1]-=minR; s[2]-=minC; });

        let virtualTiles = slots.map((s, i) => ({ id: i, z: s[0], r: s[1], c: s[2], active: true }));

        let pairs = [], tempTiles, success = false, attempt = 0;
        while(!success && attempt < 20) {
            tempTiles = JSON.parse(JSON.stringify(virtualTiles)); pairs = []; let possible = true;
            while(tempTiles.some(t => t.active)) {
                let available = getAvailableTiles(tempTiles);
                if(available.length < 2) { possible = false; break; }
                let t1 = available.splice(Math.floor(Math.random()*available.length), 1)[0];
                let t2 = available.splice(Math.floor(Math.random()*available.length), 1)[0];
                pairs.push([t1.id, t2.id]); t1.active = false; t2.active = false;
            }
            if(possible) success = true; attempt++;
        }
        if(!success) for(let i=0;i<virtualTiles.length;i+=2) pairs.push([i,i+1]);

        let totalPairs = pairs.length, cardInventory = [], shuffledTypes = [...rawTiles].sort(()=>Math.random()-0.5);
        let typeIndex = 0;
        for(let i=0; i<totalPairs; i+=2) {
            let card = shuffledTypes[typeIndex % shuffledTypes.length];
            cardInventory.push(card); if(i+1<totalPairs) cardInventory.push(card);
            typeIndex++;
        }
        cardInventory.sort(()=>Math.random()-0.5);
        let finalTilesData = new Array(virtualTiles.length);
        pairs.forEach((pair, idx) => { finalTilesData[pair[0]] = finalTilesData[pair[1]] = cardInventory[idx]; });

        renderTiles(virtualTiles, finalTilesData);
        setTimeout(fitBoard, 50);
        updateStatusText();
    }

    function getAvailableTiles(tileSet) {
        return tileSet.filter(t => t.active && !checkLockedInSet(t, tileSet));
    }

    function checkLockedInSet(tile, tileSet) {
        let hasTop=false, hasLeft=false, hasRight=false;
        for(let other of tileSet) {
            if(!other.active || other.id === tile.id) continue;
            if(other.z === tile.z+1 && other.r === tile.r && other.c === tile.c) hasTop = true;
            if(other.z === tile.z && other.r === tile.r) { if(other.c === tile.c-1) hasLeft=true; if(other.c === tile.c+1) hasRight=true; }
        }
        return hasTop || (hasLeft && hasRight);
    }

    function renderTiles(slots, dataMap) {
        const board = document.getElementById('game-board');
        let maxX=0, maxY=0;
        
        slots.forEach((slot, index) => {
            if(slot.c > maxX) maxX = slot.c;
            if(slot.r > maxY) maxY = slot.r;
            
            const el = document.createElement('div');
            el.className = 'tile';
            // åŠ å…¥ data-layer å±¬æ€§ï¼Œç”¨æ–¼ CSS ä¸åŒå±¤ç´šçš„é™°å½±æ§åˆ¶
            el.setAttribute('data-layer', slot.z);
            
            const card = dataMap[index];
            el.innerHTML = `<div class="t-suit">${card.s}</div><div class="t-icon ${card.c}">${card.i}</div><div class="t-text ${card.c}">${card.t}</div>`;
            
            // å‚ç›´å †ç–Š
            let left = slot.c * tileW + (slot.z * offsetX);
            let top = slot.r * tileH + (slot.z * offsetY); 
            
            el.style.left = left + 'px'; 
            el.style.top = top + 'px'; 
            el.style.zIndex = slot.z * 10 + slot.r; 
            
            const tileObj = { el: el, data: card, z: slot.z, r: slot.r, c: slot.c, active: true, id: index };
            el.onclick = () => onTileClick(tileObj);
            board.appendChild(el);
            tiles.push(tileObj);
        });
        
        board.style.width = (maxX + 1) * tileW + 'px';
        board.style.height = (maxY + 1) * tileH + 'px';
        
        updateLockStatus();
    }

    function updateLockStatus() {
        tiles.forEach(t => { if(!t.active) return; t.isLocked = checkLocked(t); t.el.classList.toggle('locked', t.isLocked); });
    }

    function checkLocked(tile) {
        let hasTop=false, hasLeft=false, hasRight=false;
        for(let other of tiles) {
            if(!other.active || other === tile) continue;
            if(other.z === tile.z+1 && other.r === tile.r && other.c === tile.c) hasTop = true;
            if(other.z === tile.z && other.r === tile.r) { if(other.c === tile.c-1) hasLeft=true; if(other.c === tile.c+1) hasRight=true; }
        }
        return hasTop || (hasLeft && hasRight);
    }

    function onTileClick(tile) {
        if(!tile.active || tile.isLocked) return;
        if(selectedTile === tile) { tile.el.classList.remove('selected'); selectedTile = null; }
        else if(selectedTile) {
            if(tile.data.t === selectedTile.data.t) {
                tile.active=false; selectedTile.active=false;
                tile.el.style.opacity=0; selectedTile.el.style.opacity=0;
                // ä½¿ç”¨ transform: scale(0) é€²è¡Œæ¶ˆé™¤å‹•ç•«
                tile.el.style.transform="scale(0)"; selectedTile.el.style.transform="scale(0)";
                selectedTile = null;
                setTimeout(() => { tile.el.style.display='none'; updateLockStatus(); updateStatusText(); checkGameState(); }, 150);
            } else { selectedTile.el.classList.remove('selected'); selectedTile = tile; tile.el.classList.add('selected'); }
        } else { selectedTile = tile; tile.el.classList.add('selected'); }
    }

    function checkGameState() {
        if(tiles.filter(t=>t.active).length===0) showModal('win');
        else if(!hasAvailableMoves()) showModal('lose');
    }

    function hasAvailableMoves() {
        let free = tiles.filter(t=>t.active && !t.isLocked);
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) return true;
        return false;
    }

    function showModal(type) {
        const overlay = document.getElementById('msg-overlay'), title = document.getElementById('overlay-title'), verse = document.getElementById('overlay-verse'), btn = document.getElementById('overlay-btn');
        if(type==='win') {
            title.innerText="å“ˆåˆ©è·¯äºï¼(å‹åˆ©)"; title.style.color="#FFD700"; verse.innerText=winVerses[Math.floor(Math.random()*winVerses.length)];
            btn.innerText="æŒ‘æˆ°ä¸‹ä¸€é—œ"; btn.onclick=()=>{ document.getElementById('map-select').value=['random','turtle','castle','cross','bridge','towers'][Math.floor(Math.random()*6)]; startGame(document.getElementById('map-select').value); };
        } else {
            title.innerText="æ©å…¸å¤ ç”¨ (æš«æ™‚ç„¡è·¯)"; title.style.color="#4FC3F7"; verse.innerText=loseVerses[Math.floor(Math.random()*loseVerses.length)];
            btn.innerText="é‡æ–°é–‹å§‹"; btn.onclick=()=>forceNewGame();
        }
        overlay.style.display='flex';
    }

    function shuffleActiveTiles() {
        let active=tiles.filter(t=>t.active), datas=active.map(t=>t.data), attempt=0, solvable=false;
        let freeIndices=active.map((t,i)=>!checkLocked(t)?i:-1).filter(i=>i!==-1);
        while(!solvable && attempt<50) {
            datas.sort(()=>Math.random()-0.5); let seen=new Set();
            for(let i of freeIndices) { if(seen.has(datas[i].t)) { solvable=true; break; } seen.add(datas[i].t); }
            attempt++;
        }
        active.forEach((t,i)=>{ t.data=datas[i]; t.el.classList.remove('selected'); t.el.innerHTML=`<div class="t-suit">${t.data.s}</div><div class="t-icon ${t.data.c}">${t.data.i}</div><div class="t-text ${t.data.c}">${t.data.t}</div>`; });
        selectedTile=null; document.getElementById('game-board').style.opacity=0.5; setTimeout(()=>document.getElementById('game-board').style.opacity=1, 300);
        if(!solvable) alert("ç‰Œå±€éæ–¼è¤‡é›œï¼Œå»ºè­°ç›´æ¥é–‹æ–°å±€ï¼");
    }

    function autoHint() {
        let free=tiles.filter(t=>t.active && !t.isLocked);
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) {
            free[i].el.style.background='#81d4fa'; free[j].el.style.background='#81d4fa';
            setTimeout(()=>{ free[i].el.style.background=''; free[j].el.style.background=''; }, 1500); return;
        }
        alert("ç›®å‰ç„¡è§£ï¼Œè«‹æŒ‰ã€Œæ´—ç‰Œã€ï¼");
    }

    function updateStatusText() { document.getElementById('status').innerText = "å‰©é¤˜: " + tiles.filter(t => t.active).length; }

    // --- çµ•å°ç½®ä¸­ (é…åˆ 3D è½‰æ›) ---
    function fitBoard() {
        const board = document.getElementById('game-board');
        const view = document.getElementById('game-viewport');
        if(!board || !view) return;
        
        // å…ˆé‡ç½® transformï¼Œä¿ç•™ 3D æ—‹è½‰
        board.style.transform = 'translate(-50%, -50%) rotateX(20deg) rotateZ(-5deg) scale(1)';
        
        const boardW = board.scrollWidth;
        const boardH = board.scrollHeight;
        const viewW = view.clientWidth;
        const viewH = view.clientHeight;

        // è¨ˆç®—æœ€å¤§æ¯”ä¾‹ (ç•™ 10px é‚Šè·)
        const scale = Math.min((viewW - 20) / boardW, (viewH - 20) / boardH);
        
        // æ‡‰ç”¨ï¼šä½ç§» + 3D æ—‹è½‰ + ç¸®æ”¾
        board.style.transform = `translate(-50%, -50%) rotateX(20deg) rotateZ(-5deg) scale(${scale})`;
    }
    
    window.addEventListener('resize', fitBoard);
    startGame('random'); 
</script>
</body>
</html>
