<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-title" content="ç¦éŸ³éº»é›€">
    <meta name="application-name" content="ç¦éŸ³éº»é›€">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#2c1e12"> <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="https://cokcok1.github.io/Game1/mj.png">
    <link rel="icon" type="image/png" href="https://cokcok1.github.io/Game1/mj.png">

    <title>ç¦éŸ³éº»é›€ - v39 ç´™ç›’é‡‘å­—å¡”ç‰ˆ</title>
    <style>
        :root { 
            --tile-w: 46px;
            --tile-h: 60px; 
            --depth: 16px; /* å¢åŠ åšåº¦ï¼Œè®“ç´™ç›’æ„Ÿæ›´å¼· */
            
            /* v39: èƒŒæ™¯æ”¹ç‚ºæ·±æœ¨ç´‹è‰²èª¿ */
            --bg-color: #3e2723;
            --ui-bg: #5d4037;
            --text-dark: #fff;
            
            /* v39: ç´™ç›’æè³ªé¡è‰²å®šç¾© */
            --cardboard-face: #d2b48c; /* ç´™ç®±è¡¨é¢å•¡é»ƒè‰² */
            --cardboard-side: #a1887f; /* ç´™ç®±å´é¢æ·±å•¡è‰² */
            --cardboard-ink: #3e2723;  /* å°åˆ·å¢¨æ°´æ·±å•¡è‰² */
            
            /* UI æŒ‰éˆ•è‰² (ä¿æŒä¸è®Šï¼Œç¨å¾®èª¿æš—é…åˆèƒŒæ™¯) */
            --btn-yellow-1: #ffb300; --btn-yellow-2: #ff8f00;
            --btn-blue-1: #039be5; --btn-blue-2: #0277bd;
            --btn-orange-1: #ff7043; --btn-orange-2: #d84315;
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; 
            background-color: var(--bg-color);
            /* v39: åŠ å…¥ä¸€é»ç²—ç³™çš„ç´‹ç†èƒŒæ™¯ */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3E%3Cpath fill='%239C92AC' fill-opacity='0.1' d='M1 3h1v1H1V3zm2-2h1v1H3V1z'%3E%3C/path%3E%3C/svg%3E");
            font-family: "Comic Sans MS", "Chalkboard SE", "å¹¼åœ†", "Microsoft JhengHei", sans-serif;
            overflow: hidden; display: flex; flex-direction: column; height: 100vh; height: 100dvh; 
            color: var(--text-dark); user-select: none; -webkit-user-select: none; touch-action: none;
        }
        
        header, footer, .overlay-box, #joystick-zone, #status {
            background: var(--ui-bg) !important;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            color: #efebe9;
        }

        header {
            flex-shrink: 0; 
            height: calc(50px + env(safe-area-inset-top)); 
            padding: 5px 15px;
            padding-top: calc(5px + env(safe-area-inset-top)); 
            display: flex; justify-content: space-between; align-items: center; z-index: 100; font-size: 15px;
            border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; /* UIä¹Ÿè®Šå¾—æ–¹æ­£ä¸€é» */
            margin: 0 5px 5px 5px;
        }

        select { 
            padding: 6px 10px; font-size: 14px; border-radius: 5px; 
            border: 2px solid rgba(0,0,0,0.4); background: #4e342e !important;
            max-width: 140px; color: #fff; font-weight: bold; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        option { background: #3e2723; color: #fff; }
        
        #status { font-size: 15px; font-weight: bold; background: var(--btn-yellow-1) !important; color: #3e2723; padding: 6px 15px; border-radius: 5px; box-shadow: 0 3px 0 var(--btn-yellow-2), 0 5px 10px rgba(0,0,0,0.4); border: none; }
        
        #game-viewport {
            flex: 1; width: 100%; position: relative; overflow: hidden; padding: 0;
            perspective: 2500px; /* å¢åŠ é€è¦–æ„Ÿï¼Œè®“é‡‘å­—å¡”æ›´å®å‰ */
            perspective-origin: center center;
        }

        #game-board { 
            position: absolute; 
            top: 50%; left: 50%; 
            /* v39: é è¨­è¦–è§’èª¿æ•´ï¼Œæ‹‰é«˜ä¸€é»çœ‹æ¸…å±¤æ¬¡ */
            transform: translate(-50%, -50%) rotateX(40deg) rotateZ(0deg); 
            transform-origin: center center; transform-style: preserve-3d;
        }

        footer { 
            flex-shrink: 0; height: calc(80px + env(safe-area-inset-bottom)); 
            padding: 5px 10px; padding-bottom: max(5px, env(safe-area-inset-bottom));
            display: flex; justify-content: space-between; align-items: center; z-index: 100;
            border-top-left-radius: 10px; border-top-right-radius: 10px; margin: 5px 5px 0 5px;
        }

        .footer-btns { display: flex; flex: 1; justify-content: space-around; margin-right: 10px; }
        
        .btn {
            background: linear-gradient(to bottom, var(--btn-yellow-1), var(--btn-yellow-2)); 
            border: 2px solid #3e2723; padding: 0; width: auto; flex: 1; margin: 0 3px;
            height: 44px; border-radius: 5px; font-weight: bold; font-size: 16px; 
            box-shadow: 0 4px 0 #3e2723, 0 6px 10px rgba(0,0,0,0.5); 
            cursor: pointer; display: flex; justify-content: center; align-items: center; color: #3e2723;
            transition: all 0.1s;
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 1px 0 #3e2723, 0 2px 5px rgba(0,0,0,0.5); }
        
        .btn-blue { 
            background: linear-gradient(to bottom, var(--btn-blue-1), var(--btn-blue-2)); 
            box-shadow: 0 4px 0 #01579b, 0 6px 10px rgba(0,0,0,0.5); color: white; border-color: #01579b;
        }
        .btn-blue:active { transform: translateY(3px); box-shadow: 0 1px 0 #01579b, 0 2px 5px rgba(0,0,0,0.5); }

        .btn-orange {
            background: linear-gradient(to bottom, var(--btn-orange-1), var(--btn-orange-2));
            box-shadow: 0 4px 0 #bf360c, 0 6px 10px rgba(0,0,0,0.5); color: #fff; border-color: #bf360c;
        }
        .btn-orange:active { transform: translateY(3px); box-shadow: 0 1px 0 #bf360c, 0 2px 5px rgba(0,0,0,0.5); }

        #joystick-zone {
            position: relative; width: 60px; height: 60px; z-index: 150; flex-shrink: 0;
            background: rgba(0, 0, 0, 0.4) !important; 
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; 
            touch-action: none; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.6), inset 0 2px 5px rgba(0,0,0,0.5);
        }
        #joystick-knob {
            width: 28px; height: 28px; background: var(--btn-yellow-1);
            border-radius: 50%; border: 2px solid #3e2723; box-shadow: 0 3px 5px rgba(0,0,0,0.5); position: relative;
        }
        #joystick-hint {
            position: absolute; bottom: -15px; width: 100%; text-align: center;
            font-size: 9px; color: rgba(255, 255, 255, 0.6); pointer-events: none; font-weight: bold;
        }

        /* --- v39 æ ¸å¿ƒï¼šå¯¦é«”ç´™ç›’éº»é›€ (Cardboard Box) --- */
        .tile {
            position: absolute; width: var(--tile-w); height: var(--tile-h);
            
            /* ç‰Œé¢ï¼šç´™æ¿å•¡é»ƒè‰²ï¼Œå•å…‰ */
            background-color: var(--cardboard-face);
            /* v39: ç›´è§’ï¼Œç„¡åœ“æ½¤æ„Ÿ */
            border-radius: 1px; 
            
            cursor: pointer;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            /* ç§»é™¤æ‰€æœ‰é«˜å…‰ï¼Œåªä¿ç•™æ¥µç´°å¾®çš„ç´™æ¿ç´‹ç†æ„Ÿ */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
            /* é‚Šç·£ç”¨æ·±è‰²ç·šæ¢å‹¾å‹’ç´™ç›’æ¥ç¸« */
            border: 1px solid rgba(0,0,0,0.2);
            
            transform-style: preserve-3d; transition: transform 0.15s;
        }

        /* ç¨ç«‹é™°å½±å±¤ (æ–¹æ­£çš„é™°å½±) */
        .tile-shadow-layer {
            position: absolute; width: 100%; height: 100%; top:0; left:0;
            border-radius: 1px; pointer-events: none;
            transform: translateZ(-1px);
            background: transparent;
            /* çµå¯¦çš„é»‘è‰²é™°å½± */
            box-shadow: 2px 2px 4px rgba(0,0,0,0.6), 5px 5px 15px rgba(0,0,0,0.3);
        }

        /* v39: å´é¢ (Bottom) - å–®ä¸€æ·±å•¡è‰²ç´™æ¿ */
        .tile::before {
            content: ''; position: absolute; width: 100%; height: var(--depth);
            bottom: 0; left: 0;
            transform-origin: bottom; transform: rotateX(-90deg);
            border-radius: 0 0 1px 1px;
            background-color: var(--cardboard-side);
            /* ç°¡å–®çš„å´é¢å…‰å½±ï¼Œä¸éœ€è¤‡é›œæ¼¸è®Š */
            background-image: linear-gradient(to bottom, rgba(0,0,0,0.1), rgba(0,0,0,0.3));
            border: 1px solid rgba(0,0,0,0.3); border-top: none;
        }
        
        /* v39: å´é¢ (Right) - å–®ä¸€æ·±å•¡è‰²ç´™æ¿ */
        .tile::after {
            content: ''; position: absolute; width: var(--depth); height: 100%;
            top: 0; right: 0;
            transform-origin: right; transform: rotateY(90deg);
            border-radius: 0 1px 1px 0;
            background-color: var(--cardboard-side);
            background-image: linear-gradient(to right, rgba(0,0,0,0.1), rgba(0,0,0,0.2));
            border: 1px solid rgba(0,0,0,0.3); border-left: none;
        }

        /* é–å®šç‹€æ…‹ï¼šè®Šæš—çš„ç´™æ¿ */
        .tile.locked { 
            background-color: #a1887f; 
            filter: brightness(0.8) sepia(0.3); /* åŠ é»èˆŠç´™ç®±æ„Ÿè¦º */
        }
        .tile.locked::before, .tile.locked::after { background-color: #8d6e63; }
        .tile.locked img, .tile.locked .t-icon { opacity: 0.5; }

        /* é¸ä¸­ç‹€æ…‹ï¼šæµ®èµ· */
        .tile.selected { 
            background-color: #ffe0b2; /* é¸ä¸­è®Šäº®é»ƒç´™æ¿ */
            transform: translateZ(calc(var(--base-z) + 15px)) !important; 
            z-index: 9999 !important;
            border: 2px solid var(--btn-orange-2);
        }
        .tile.selected .tile-shadow-layer {
            box-shadow: 15px 20px 40px rgba(0,0,0,0.5);
            transform: translateZ(-15px);
        }

        /* v39: å…§å®¹æ¨£å¼ - å°åˆ·å¢¨æ°´æ„Ÿ (ç„¡åˆ»ç—•) */
        .t-suit { 
            position: absolute; top: 3px; right: 5px; font-size: 10px; 
            color: var(--cardboard-ink); /* å¢¨æ°´è‰² */
            line-height: 1; backface-visibility: hidden; font-weight: bold; 
            opacity: 0.7;
            text-shadow: none; /* ç§»é™¤æ‰€æœ‰ç«‹é«”æ•ˆæœ */
        }
        .t-icon { 
            font-size: 30px; line-height: 1; margin-top: 2px; backface-visibility: hidden; 
            color: var(--cardboard-ink); /* å¢¨æ°´è‰² */
            filter: none; /* ç§»é™¤æŠ•å½± */
            /* æ¨¡æ“¬å°åˆ·çš„è¼•å¾®æ¨¡ç³Šæ„Ÿ */
            text-shadow: 0 0 1px rgba(62, 39, 35, 0.5);
        }
        .t-text { 
            font-size: 12px; font-weight: 900; margin-top: 2px; 
            color: var(--cardboard-ink); /* å¢¨æ°´è‰² */
            backface-visibility: hidden; 
            text-shadow: none;
        }
        
        /* é¡è‰²å¾®èª¿ç‚ºè¼ƒæ·±æ²‰çš„å°åˆ·è‰² */
        .c-red { color: #b71c1c !important; } .c-blue { color: #0d47a1 !important; } .c-green { color: #1b5e20 !important; }

        #msg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); 
            display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center; padding: 20px;
        }
        .overlay-box {
            background: var(--cardboard-face); padding: 30px; border-radius: 5px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); border: 4px solid #3e2723;
            max-width: 90%; color: #3e2723;
        }
        .overlay-title { font-size: 36px; font-weight: bold; margin-bottom: 20px; color: var(--btn-orange-2); text-shadow: none; }
        .overlay-verse { 
            font-size: 22px; color: #3e2723; line-height: 1.6; 
            background: rgba(0,0,0,0.05); padding: 20px; border-radius: 5px; 
            width: 100%; margin-bottom: 20px; border: 2px dashed #3e2723;
            font-weight: bold; 
        }

        #watermark {
            position: absolute; bottom: 95px; left: 20px; font-size: 11px;
            color: rgba(255, 255, 255, 0.3); pointer-events: none; z-index: 150; font-weight: bold;
        }
    </style>
</head>
<body>

<header>
    <select id="map-select" onchange="changeMap(this.value)">
        <option value="pyramid_brick">å³ å°‡ ç Œ ç£š é‡‘ å­— å¡”</option>
        <option value="turtle_real">ğŸ¢ ç¶“å…¸é¾œèƒŒ (çœŸ)</option>
        <option value="random">ğŸ² ç„¡é™éš¨æ©Ÿ</option>
        <option value="castle">ğŸ° å …å›ºå ¡å£˜</option>
    </select>
    <div id="status">å‰©é¤˜: 0</div>
</header>

<div id="game-viewport">
    <div id="game-board"></div>
</div>

<footer>
    <div class="footer-btns">
        <button class="btn btn-blue" onclick="forceNewGame()">ğŸ”„ æ–°å±€</button>
        <button class="btn btn-orange" onclick="undoMove()">â†©ï¸ å¾©åŸ</button>
        <button class="btn" onclick="autoHint()">ğŸ’¡ æç¤º</button>
    </div>
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
        <div id="joystick-hint">è¦–è§’</div>
    </div>
</footer>

<div id="watermark">Powered by Google Gemini v39 (Cardboard Brick Pyramid)</div>

<div id="msg-overlay">
    <div class="overlay-box">
        <div id="overlay-title" class="overlay-title"></div>
        <div id="overlay-verse" class="overlay-verse"></div>
        <button id="overlay-btn" class="btn" style="width: 220px; height: 50px; font-size: 20px;" onclick="forceNewGame()">æŒ‘æˆ°ä¸‹ä¸€é—œ</button>
    </div>
</div>

<script>
    const rawTiles = [
        {t:"æ‘©è¥¿", i:"ğŸŒŠ", s:"è¬", c:"c-red"}, {t:"å¤§è¡›", i:"ğŸ‘‘", s:"è¬", c:"c-red"},
        {t:"ä¿ç¾…", i:"ğŸ“œ", s:"è¬", c:"c-red"}, {t:"å½¼å¾—", i:"ğŸŸ", s:"è¬", c:"c-red"},
        {t:"ç´„æ‹¿", i:"ğŸ‹", s:"è¬", c:"c-red"}, {t:"é¦¬åˆ©äº", i:"ğŸ¤°", s:"è¬", c:"c-red"},
        {t:"äºä¼¯è˜­", i:"ğŸ‘", s:"è¬", c:"c-red"}, {t:"ä½†ä»¥ç†", i:"ğŸ¦", s:"è¬", c:"c-red"},
        {t:"æ•™æœƒ", i:"â›ª", s:"ç­’", c:"c-blue"}, {t:"è¥¿å¥ˆ", i:"â›°ï¸", s:"ç­’", c:"c-blue"},
        {t:"ç´…æµ·", i:"ğŸŒŠ", s:"ç­’", c:"c-blue"}, {t:"ä¼Šç”¸", i:"ğŸ", s:"ç­’", c:"c-blue"},
        {t:"åŠ åˆ©åˆ©", i:"ğŸ›¶", s:"ç­’", c:"c-blue"}, {t:"è–æ®¿", i:"ğŸ›ï¸", s:"ç­’", c:"c-blue"},
        {t:"è€¶åˆ©å“¥", i:"ğŸ§±", s:"ç­’", c:"c-blue"}, {t:"æ–¹èˆŸ", i:"ğŸš¢", s:"ç­’", c:"c-blue"},
        {t:"åæ¶", i:"âœï¸", s:"ç´¢", c:"c-green"}, {t:"è–ç¶“", i:"ğŸ“–", s:"ç´¢", c:"c-green"},
        {t:"äº”é¤…", i:"ğŸ", s:"ç´¢", c:"c-green"}, {t:"äºŒé­š", i:"ğŸŸ", s:"ç´¢", c:"c-green"},
        {t:"å¯¶è¡€", i:"ğŸ·", s:"ç´¢", c:"c-green"}, {t:"è–éˆ", i:"ğŸ•Šï¸", s:"ç´¢", c:"c-green"},
        {t:"ä¿¡", i:"ğŸ›¡ï¸", s:"ç•ª", c:"#333"}, {t:"æœ›", i:"âš“", s:"ç•ª", c:"#333"},
        {t:"æ„›", i:"â¤ï¸", s:"ç•ª", c:"#333"}, {t:"é˜¿å€‘", i:"ğŸ™", s:"ç•ª", c:"#333"},
        {t:"ç¦±å‘Š", i:"ğŸ¤²", s:"ç•ª", c:"#333"}, {t:"å¾©æ´»", i:"ğŸŒ…", s:"ç•ª", c:"#333"},
        {t:"æŒªäº", i:"ğŸŒˆ", s:"è¬", c:"c-red"}, {t:"ç´„æ›¸äº", i:"ğŸº", s:"è¬", c:"c-red"},
        {t:"ä»¥åˆ©äº", i:"ğŸ”¥", s:"è¬", c:"c-red"}, 
        {t:"è‘¡è„", i:"ğŸ‡", s:"ç´¢", c:"c-green"}, {t:"ç£çŸ³", i:"ğŸª¨", s:"ç´¢", c:"c-green"},
        {t:"äº®å…‰", i:"ğŸ’¡", s:"ç­’", c:"c-blue"}, {t:"å¤©åœ‹", i:"â˜ï¸", s:"ç­’", c:"c-blue"},
        {t:"å–œæ¨‚", i:"ğŸ˜„", s:"ç•ª", c:"#333"}
    ];
    
    const winVerses = ["æµæ·šæ’’ç¨®çš„ï¼Œå¿…æ­¡å‘¼æ”¶å‰²ã€‚(è©© 126:5)", "é‚£ç¾å¥½çš„ä»—æˆ‘å·²ç¶“æ‰“éäº†ã€‚(æå¾Œ 4:7)", "é è‘—é‚£åŠ çµ¦æˆ‘åŠ›é‡çš„ï¼Œå‡¡äº‹éƒ½èƒ½åšã€‚(è…“ 4:13)", "ä½ å€‘æ˜¯ä¸–ä¸Šçš„å…‰ã€‚(å¤ª 5:14)", "å¾—å‹çš„ï¼Œæˆ‘è¦è³œä»–åœ¨æˆ‘å¯¶åº§ä¸Šèˆ‡æˆ‘åŒåã€‚(å•Ÿ 3:21)"];
    const loseVerses = ["æˆ‘çš„æ©å…¸æ˜¯å¤ ä½ ç”¨çš„ã€‚(æ—å¾Œ 12:9)", "æ‡‰ç•¶ä¸€ç„¡æ›æ…®ï¼Œåªè¦å‡¡äº‹è—‰è‘—ç¦±å‘Šã€‚(è…“ 4:6)", "ä½ å€‘è¦ä¼‘æ¯ï¼Œè¦çŸ¥é“æˆ‘æ˜¯ç¥ã€‚(è©© 46:10)", "è¬äº‹éƒ½äº’ç›¸æ•ˆåŠ›ã€‚(ç¾… 8:28)"];

    const MapBlueprints = {
        pyramid_brick: () => generateBrickPyramid(), // v39 æ–°å¢ï¼šç Œç£šé‡‘å­—å¡”
        turtle_real: () => generateTrueTurtle(),
        castle: () => generateWall(6, 8),
        random: () => generateChaos()
    };

    // v39: çœŸæ­£çš„ç Œç£šé‡‘å­—å¡” (æ¯å±¤ä½ç§» 0.5)
    function generateBrickPyramid() {
        let slots = [];
        // Layer 0: 8x10 åº•åº§ (èµ·å§‹ 0,0)
        for(let r=0; r<8; r++) for(let c=0; c<10; c++) slots.push([0, r, c]);
        
        // Layer 1: 7x9 (èµ·å§‹ 0.5, 0.5) - å£“åœ¨L0çš„åå­—ä½
        for(let r=0; r<7; r++) for(let c=0; c<9; c++) slots.push([1, r+0.5, c+0.5]);

        // Layer 2: 6x8 (èµ·å§‹ 1.0, 1.0) - å£“åœ¨L1çš„åå­—ä½
        for(let r=0; r<6; r++) for(let c=0; c<8; c++) slots.push([2, r+1, c+1]);

        // Layer 3: 5x7 (èµ·å§‹ 1.5, 1.5)
        for(let r=0; r<5; r++) for(let c=0; c<7; c++) slots.push([3, r+1.5, c+1.5]);
        
        // Layer 4: 4x6 (èµ·å§‹ 2.0, 2.0)
        for(let r=0; r<4; r++) for(let c=0; c<6; c++) slots.push([4, r+2, c+2]);

        // Layer 5: 2x4 (å¡”é ‚)
        for(let r=1; r<3; r++) for(let c=1; c<5; c++) slots.push([5, r+2.5, c+2.5]);

        return slots;
    }

    // v38: é¾œèƒŒé™£ (ä¿ç•™)
    function generateTrueTurtle() {
        let slots = [];
        for(let r=0; r<8; r++) for(let c=0; c<10; c++) slots.push([0, r, c]);
        for(let r=1; r<7; r++) for(let c=2; c<8; c++) slots.push([1, r, c]);
        for(let r=2; r<6; r++) for(let c=3; c<7; c++) slots.push([2, r, c]);
        for(let r=3; r<5; r++) for(let c=4; c<6; c++) slots.push([3, r, c]);
        slots.push([4, 3.5, 4.5]);
        slots.push([0, 3.5, -1]); slots.push([0, 3.5, 10]);
        slots.push([0, 3.5, -2]); slots.push([0, 3.5, 11]);
        return slots;
    }

    function generateWall(rows, cols) { let slots=[]; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) { slots.push([0, r, c]); if(r===0||r===rows-1||c===0||c===cols-1) slots.push([1, r, c]); } return slots; }
    function generateChaos() { let slots=[]; for(let r=0;r<6;r++) for(let c=0;c<8;c++) slots.push([0,r,c]); for(let i=0;i<32;i++) slots.push([Math.floor(Math.random()*2)+1, Math.floor(Math.random()*4)+1, Math.floor(Math.random()*6)+1]); return slots; }

    let tiles = [];
    let selectedTile = null;
    let moveHistory = [];
    let tileW = 46, tileH = 60; 
    let globalScale = 1;
    let viewRotX = 40; // v39: è¦–è§’èª¿é«˜
    let viewRotZ = 0;

    function changeMap(val) { startGame(val); }
    function forceNewGame() { startGame(document.getElementById('map-select').value); }

    function startGame(mapType) {
        document.getElementById('msg-overlay').style.display = 'none';
        const board = document.getElementById('game-board');
        board.innerHTML = ''; tiles = []; selectedTile = null; moveHistory = [];
        
        let slots = MapBlueprints[mapType]();
        if(slots.length % 2 !== 0) slots.pop();
        
        let minC = Infinity, maxC = -Infinity, minR = Infinity, maxR = -Infinity;
        slots.forEach(s => { 
            if(s[1]<minR) minR=s[1]; if(s[1]>maxR) maxR=s[1];
            if(s[2]<minC) minC=s[2]; if(s[2]>maxC) maxC=s[2];
        });
        let centerR = (minR + maxR) / 2;
        let centerC = (minC + maxC) / 2;
        
        let virtualTiles = slots.map((s, i) => ({ 
            id: i, z: s[0], r: s[1] - centerR, c: s[2] - centerC, active: true 
        }));

        let pairs = [], tempTiles, success = false, attempt = 0;
        while(!success && attempt < 50) { 
            tempTiles = JSON.parse(JSON.stringify(virtualTiles)); pairs = []; let possible = true;
            while(tempTiles.some(t => t.active)) {
                let available = getAvailableTiles(tempTiles);
                if(available.length < 2) { possible = false; break; }
                let t1 = available.splice(Math.floor(Math.random()*available.length), 1)[0];
                let t2 = available.splice(Math.floor(Math.random()*available.length), 1)[0]; 
                tempTiles.find(t=>t.id===t1.id).active = false;
                tempTiles.find(t=>t.id===t2.id).active = false;
                pairs.push([t1.id, t2.id]);
            }
            if(possible) success = true; attempt++;
        }
        if(!success) { console.log("ç”Ÿæˆå¤±æ•—ï¼Œä½¿ç”¨ä¿åº•"); pairs=[]; for(let i=0;i<virtualTiles.length;i+=2) pairs.push([virtualTiles[i].id, virtualTiles[i+1].id]); }

        let totalPairs = pairs.length, cardInventory = [], shuffledTypes = [...rawTiles].sort(()=>Math.random()-0.5);
        let typeIndex = 0;
        for(let i=0; i<totalPairs; i+=2) {
            let card = shuffledTypes[typeIndex % shuffledTypes.length];
            cardInventory.push(card); if(i+1<totalPairs) cardInventory.push(card);
            typeIndex++;
        }
        while(cardInventory.length < totalPairs) cardInventory.push(shuffledTypes[Math.floor(Math.random()*shuffledTypes.length)]);
        cardInventory.sort(()=>Math.random()-0.5);
        
        let finalTilesData = new Array(virtualTiles.length);
        pairs.forEach((pair, idx) => { 
            finalTilesData[pair[0]] = cardInventory[idx]; 
            finalTilesData[pair[1]] = cardInventory[idx]; 
        });

        renderTiles(virtualTiles, finalTilesData);
        setTimeout(fitBoard, 50);
        updateStatusText();
    }

    function getAvailableTiles(tileSet) { return tileSet.filter(t => t.active && !isBlocked(t, tileSet)); }

    function isBlocked(tile, allTiles) {
        // v38/v39 æ ¸å¿ƒï¼šåŠæ ¼åˆ¤å®šé‚è¼¯
        let isCovered = allTiles.some(other => 
            other.active && other.id !== tile.id && other.z > tile.z && 
            Math.abs(other.r - tile.r) < 1 && Math.abs(other.c - tile.c) < 1
        );
        if (isCovered) return true;

        let leftBlocked = allTiles.some(other => 
            other.active && other.id !== tile.id && other.z === tile.z && 
            Math.abs(other.r - tile.r) < 1 && other.c < tile.c && (tile.c - other.c) <= 1
        );
        let rightBlocked = allTiles.some(other => 
            other.active && other.id !== tile.id && other.z === tile.z && 
            Math.abs(other.r - tile.r) < 1 && other.c > tile.c && (other.c - tile.c) <= 1
        );
        return leftBlocked && rightBlocked;
    }

    function checkLocked(tileObj) { return isBlocked(tileObj, tiles); }

    function renderTiles(slots, dataMap) {
        const board = document.getElementById('game-board');
        slots.forEach((slot, index) => {
            const el = document.createElement('div');
            el.className = 'tile';
            const card = dataMap[index];
            el.innerHTML = `<div class="tile-shadow-layer"></div><div class="t-suit">${card.s}</div><div class="t-icon ${card.c}">${card.i}</div><div class="t-text ${card.c}">${card.t}</div>`;
            
            let left = slot.c * tileW; 
            let top = slot.r * tileH; 
            let zHeight = slot.z * 16; // v39: å¢åŠ å±¤é«˜
            
            el.style.left = 0 + 'px'; el.style.top = 0 + 'px';
            el.style.transform = `translate(${left}px, ${top}px) translateZ(${zHeight}px)`;
            el.dataset.baseTrans = `translate(${left}px, ${top}px) translateZ(${zHeight}px)`;
            el.style.zIndex = Math.floor(slot.z * 100 + slot.r + slot.c + 1000); 
            
            const tileObj = { el: el, data: card, z: slot.z, r: slot.r, c: slot.c, active: true, id: index };
            el.onclick = () => onTileClick(tileObj);
            board.appendChild(el);
            tiles.push(tileObj);
        });
        updateLockStatus();
    }

    function updateLockStatus() { tiles.forEach(t => { if(!t.active) return; t.isLocked = checkLocked(t); t.el.classList.toggle('locked', t.isLocked); }); }

    function onTileClick(tile) {
        if(!tile.active || tile.isLocked) return;
        if(selectedTile === tile) { 
            tile.el.classList.remove('selected'); 
            tile.el.style.transform = tile.el.dataset.baseTrans;
            selectedTile = null; 
        }
        else if(selectedTile) {
            if(tile.data.t === selectedTile.data.t) {
                moveHistory.push([tile, selectedTile]);
                tile.active=false; selectedTile.active=false;
                tile.el.style.display='none'; selectedTile.el.style.display='none'; 
                selectedTile = null;
                updateLockStatus(); updateStatusText(); checkGameState();
            } else { 
                selectedTile.el.classList.remove('selected'); 
                selectedTile.el.style.transform = selectedTile.el.dataset.baseTrans;
                selectedTile = tile; 
                tile.el.classList.add('selected'); 
                tile.el.style.transform = `${tile.el.dataset.baseTrans} translateZ(20px)`;
            }
        } else { 
            selectedTile = tile; 
            tile.el.classList.add('selected'); 
            tile.el.style.transform = `${tile.el.dataset.baseTrans} translateZ(20px)`;
        }
    }

    function undoMove() {
        if (moveHistory.length === 0) return; 
        const lastMove = moveHistory.pop();
        const tile1 = lastMove[0]; const tile2 = lastMove[1];
        tile1.active = true; tile2.active = true;
        tile1.el.style.display = ''; tile2.el.style.display = '';
        tile1.el.classList.remove('selected'); tile2.el.classList.remove('selected');
        tile1.el.style.transform = tile1.el.dataset.baseTrans;
        tile2.el.style.transform = tile2.el.dataset.baseTrans;
        if(selectedTile) { 
            selectedTile.el.classList.remove('selected'); 
            selectedTile.el.style.transform = selectedTile.el.dataset.baseTrans;
            selectedTile = null; 
        }
        updateLockStatus(); updateStatusText();
    }

    function checkGameState() { if(tiles.filter(t=>t.active).length===0) showModal('win'); else if(!hasAvailableMoves()) showModal('lose'); }
    
    function hasAvailableMoves() {
        let free = tiles.filter(t=>t.active && !checkLocked(t));
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) return true;
        return false;
    }

    function showModal(type) {
        const overlay = document.getElementById('msg-overlay'), title = document.getElementById('overlay-title'), verse = document.getElementById('overlay-verse'), btn = document.getElementById('overlay-btn');
        if(type==='win') {
            title.innerText="ğŸ‰ å“ˆåˆ©è·¯äºï¼(å‹åˆ©)"; title.style.color="#ffb300"; verse.innerText=winVerses[Math.floor(Math.random()*winVerses.length)];
            btn.innerText="æŒ‘æˆ°ä¸‹ä¸€é—œ ğŸš€"; btn.onclick=()=>{ document.getElementById('map-select').value=['pyramid_brick','turtle_real','random','castle'][Math.floor(Math.random()*4)]; startGame(document.getElementById('map-select').value); };
            btn.className = "btn"; 
        } else {
            title.innerText="ğŸ’ª æ©å…¸å¤ ç”¨ (æš«æ™‚ç„¡è·¯)"; title.style.color="#039be5"; verse.innerText=loseVerses[Math.floor(Math.random()*loseVerses.length)];
            btn.innerText="é‡æ–°é–‹å§‹ ğŸ”„"; btn.onclick=()=>forceNewGame();
            btn.className = "btn btn-blue"; 
        }
        overlay.style.display='flex';
    }

    function shuffleActiveTiles() {
        let active=tiles.filter(t=>t.active), datas=active.map(t=>t.data), attempt=0, solvable=false;
        let freeIndices=active.map((t,i)=>!checkLocked(t)?i:-1).filter(i=>i!==-1);
        while(!solvable && attempt<50) {
            datas.sort(()=>Math.random()-0.5); let seen=new Set();
            for(let i of freeIndices) { if(seen.has(datas[i].t)) { solvable=true; break; } seen.add(datas[i].t); }
            attempt++;
        }
        active.forEach((t,i)=>{ t.data=datas[i]; t.el.classList.remove('selected'); t.el.style.transform = t.el.dataset.baseTrans;
            t.el.innerHTML=`<div class="tile-shadow-layer"></div><div class="t-suit">${t.data.s}</div><div class="t-icon ${t.data.c}">${t.data.i}</div><div class="t-text ${t.data.c}">${t.data.t}</div>`; 
        });
        selectedTile=null; document.getElementById('game-board').style.opacity=0.5; setTimeout(()=>document.getElementById('game-board').style.opacity=1, 300);
        moveHistory = [];
    }

    function autoHint() {
        let free=tiles.filter(t=>t.active && !checkLocked(t));
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) {
            free[i].el.style.transform += " scale(1.1)"; free[j].el.style.transform += " scale(1.1)";
            free[i].el.style.filter = "brightness(1.2)"; free[j].el.style.filter = "brightness(1.2)";
            setTimeout(()=>{ 
                if(free[i].active) { free[i].el.style.transform = free[i].el.dataset.baseTrans; free[i].el.style.filter = ""; }
                if(free[j].active) { free[j].el.style.transform = free[j].el.dataset.baseTrans; free[j].el.style.filter = ""; }
            }, 1000); return;
        }
        alert("ç›®å‰ç„¡è§£ï¼Œè«‹æŒ‰ã€Œæ´—ç‰Œã€ï¼");
    }

    function updateStatusText() { document.getElementById('status').innerText = "å‰©é¤˜: " + tiles.filter(t => t.active).length; }

    function applyViewTransform() {
        const board = document.getElementById('game-board');
        if(!board) return;
        board.style.transform = `translate(-50%, -50%) rotateX(${viewRotX}deg) rotateZ(${viewRotZ}deg) scale(${globalScale})`;
    }

    function fitBoard() {
        const board = document.getElementById('game-board');
        const view = document.getElementById('game-viewport');
        if(!board || !view) return;
        board.style.transform = 'none';
        const boardW = 700; const boardH = 700;
        const viewW = view.clientWidth; const viewH = view.clientHeight;
        globalScale = Math.min((viewW - 40) / boardW, (viewH - 40) / boardH);
        if(globalScale > 1.2) globalScale = 1.2;
        applyViewTransform();
    }
    window.addEventListener('resize', fitBoard);

    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');
    let isDragging = false;
    let startX, startY;
    let initialRotX, initialRotZ;

    function handleStart(e) {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
        initialRotX = viewRotX; initialRotZ = viewRotZ;
        joystickKnob.style.transition = 'none';
    }

    function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault(); 
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        const maxDist = 30;
        const dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
        const limitedDist = Math.min(dist, maxDist);
        const angle = Math.atan2(deltaY, deltaX);
        const knobX = Math.cos(angle) * limitedDist;
        const knobY = Math.sin(angle) * limitedDist;
        joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
        viewRotZ = initialRotZ + (deltaX * 0.5); 
        viewRotX = initialRotX - (deltaY * 0.5); 
        viewRotX = Math.max(0, Math.min(viewRotX, 60)); 
        applyViewTransform();
    }

    function handleEnd() {
        isDragging = false;
        joystickKnob.style.transition = 'transform 0.2s';
        joystickKnob.style.transform = 'translate(0, 0)';
    }

    joystickZone.addEventListener('mousedown', handleStart);
    joystickZone.addEventListener('touchstart', handleStart, {passive: false});
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('touchmove', handleMove, {passive: false});
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('touchend', handleEnd);

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('./sw.js')
                .then(function(registration) { console.log('SW OK'); }, function(err) { console.log('SW Fail'); });
        });
    }

    // v39: é è¨­å•Ÿå‹•æ–°çš„ç Œç£šé‡‘å­—å¡”
    document.getElementById('map-select').value = 'pyramid_brick';
    startGame('pyramid_brick'); 
</script>
</body>
</html>
