<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-title" content="ç¦éŸ³éº»é›€">
    <meta name="application-name" content="ç¦éŸ³éº»é›€">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#054a29">
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="https://cokcok1.github.io/Game1/mj.png">
    <link rel="icon" type="image/png" href="https://cokcok1.github.io/Game1/mj.png">

    <title>ç¦éŸ³éº»é›€ - v38 çµ‚æ¥µä»¿çœŸç‰ˆ</title>
    <style>
        :root { 
            --tile-w: 46px; /* ç¨å¾®åŠ å¯¬ï¼Œé…åˆåœ“æ½¤æ„Ÿ */
            --tile-h: 60px; 
            --depth: 14px; /* åšåº¦ */
            
            --bg-color: #054a29;
            --ui-bg: #085e35;
            --text-dark: #fff;
            
            /* éº»é›€é›™å±¤æè³ªé¡è‰² */
            --tile-bone-color: #fdfdfd; /* ä¸Šå±¤ï¼šéª¨ç™½ */
            --tile-back-color: #004d26; /* ä¸‹å±¤ï¼šæ·±ç¶  */
            --tile-shadow-color: rgba(0,0,0,0.5);
            
            /* UI æŒ‰éˆ•è‰² */
            --btn-yellow-1: #ffd54f; --btn-yellow-2: #ffb300;
            --btn-blue-1: #4fc3f7; --btn-blue-2: #0288d1;
            --btn-orange-1: #ffab91; --btn-orange-2: #d84315;
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; 
            background-color: var(--bg-color);
            background-image: none;
            font-family: "Comic Sans MS", "Chalkboard SE", "å¹¼åœ†", "Microsoft JhengHei", sans-serif;
            overflow: hidden; display: flex; flex-direction: column; height: 100vh; height: 100dvh; 
            color: var(--text-dark); user-select: none; -webkit-user-select: none; touch-action: none;
        }
        
        header, footer, .overlay-box, #joystick-zone, #status {
            background: var(--ui-bg) !important;
            border: 2px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        header {
            flex-shrink: 0; 
            height: calc(50px + env(safe-area-inset-top)); 
            padding: 5px 15px;
            padding-top: calc(5px + env(safe-area-inset-top)); 
            display: flex; justify-content: space-between; align-items: center; z-index: 100; font-size: 15px;
            border-bottom-left-radius: 20px; border-bottom-right-radius: 20px;
            margin: 0 10px 5px 10px;
        }

        select { 
            padding: 6px 10px; font-size: 14px; border-radius: 15px; 
            border: 2px solid rgba(0,0,0,0.3); background: #043a20 !important;
            max-width: 140px; color: #fff; font-weight: bold; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        option { background: #333; color: #fff; }
        
        #status { font-size: 15px; font-weight: bold; background: rgba(255, 213, 79, 1) !important; color: #5d4037; padding: 6px 15px; border-radius: 20px; box-shadow: 0 3px 0 #ffca28, 0 5px 10px rgba(0,0,0,0.3); border: none; }
        
        #game-viewport {
            flex: 1; width: 100%; position: relative; overflow: hidden; padding: 0;
            perspective: 2000px; perspective-origin: center center;
        }

        #game-board { 
            position: absolute; 
            top: 50%; left: 50%; 
            /* v38: é è¨­è¦–è§’èª¿æ•´ï¼Œé©æ‡‰æ–°ç«‹é«”æ„Ÿ */
            transform: translate(-50%, -50%) rotateX(25deg) rotateZ(0deg); 
            transform-origin: center center; transform-style: preserve-3d;
        }

        footer { 
            flex-shrink: 0; height: calc(80px + env(safe-area-inset-bottom)); 
            padding: 5px 10px; padding-bottom: max(5px, env(safe-area-inset-bottom));
            display: flex; justify-content: space-between; align-items: center; z-index: 100;
            border-top-left-radius: 25px; border-top-right-radius: 25px; margin: 5px 10px 0 10px;
        }

        .footer-btns { display: flex; flex: 1; justify-content: space-around; margin-right: 10px; }
        
        .btn {
            background: linear-gradient(to bottom, var(--btn-yellow-1), var(--btn-yellow-2)); 
            border: 2px solid #fff; padding: 0; width: auto; flex: 1; margin: 0 3px;
            height: 44px; border-radius: 25px; font-weight: bold; font-size: 16px; 
            box-shadow: 0 4px 0 #e65100, 0 6px 10px rgba(0,0,0,0.4); 
            cursor: pointer; display: flex; justify-content: center; align-items: center; color: #3e2723;
            transition: all 0.1s;
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 1px 0 #e65100, 0 2px 5px rgba(0,0,0,0.4); }
        
        .btn-blue { 
            background: linear-gradient(to bottom, var(--btn-blue-1), var(--btn-blue-2)); 
            box-shadow: 0 4px 0 #01579b, 0 6px 10px rgba(0,0,0,0.4); color: white; border-color: #e1f5fe;
        }
        .btn-blue:active { transform: translateY(3px); box-shadow: 0 1px 0 #01579b, 0 2px 5px rgba(0,0,0,0.4); }

        .btn-orange {
            background: linear-gradient(to bottom, #ffcc80, #ff9800);
            box-shadow: 0 4px 0 #bf360c, 0 6px 10px rgba(0,0,0,0.4); color: #3e2723; border-color: #fff3e0;
        }
        .btn-orange:active { transform: translateY(3px); box-shadow: 0 1px 0 #bf360c, 0 2px 5px rgba(0,0,0,0.4); }

        #joystick-zone {
            position: relative; width: 60px; height: 60px; z-index: 150; flex-shrink: 0;
            background: rgba(0, 0, 0, 0.3) !important; 
            border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; 
            touch-action: none; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5), inset 0 2px 5px rgba(0,0,0,0.3);
        }
        #joystick-knob {
            width: 28px; height: 28px; background: radial-gradient(circle at 30% 30%, #ffcc80, #ff9800); 
            border-radius: 50%; border: 2px solid #fff; box-shadow: 0 3px 5px rgba(0,0,0,0.4); position: relative;
        }
        #joystick-hint {
            position: absolute; bottom: -15px; width: 100%; text-align: center;
            font-size: 9px; color: rgba(255, 255, 255, 0.7); pointer-events: none; font-weight: bold;
        }

        /* --- v38 æ ¸å¿ƒï¼šé›™å±¤ä»¿çœŸæè³ªéº»é›€ --- */
        .tile {
            position: absolute; width: var(--tile-w); height: var(--tile-h);
            
            /* ç‰Œé¢ï¼šä¹³ç™½è‰²ï¼Œå¸¶åœ“è§’ */
            background-color: var(--tile-bone-color);
            border-radius: 6px; 
            
            cursor: pointer;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            /* åœ“æ½¤é«˜å…‰ */
            box-shadow: inset 0 1px 2px rgba(255,255,255,1), inset 0 -1px 2px rgba(0,0,0,0.1);
            
            transform-style: preserve-3d; transition: transform 0.15s;
        }

        /* v38: ç¨ç«‹é™°å½±å±¤ (è§£æ±ºç©¿æ¨¡èˆ‡å±¤æ¬¡æ„Ÿ) */
        .tile-shadow-layer {
            position: absolute; width: 100%; height: 100%; top:0; left:0;
            border-radius: 6px; pointer-events: none;
            transform: translateZ(-2px); /* ç¨å¾®ä¸‹æ²‰ */
            background: transparent;
            /* å¼·çƒˆçš„é»‘è‰²å±¤ç´šé™°å½± */
            box-shadow: 1px 1px 2px rgba(0,0,0,0.5), 5px 5px 10px rgba(0,0,0,0.4);
        }

        /* v38: é›™å±¤å´é¢ (Bottom) - ç™½éª¨+ç¶ èƒŒ */
        .tile::before {
            content: ''; position: absolute; width: 100%; height: var(--depth);
            bottom: 0; left: 0;
            transform-origin: bottom; transform: rotateX(-90deg);
            border-radius: 0 0 6px 6px;
            /* é—œéµï¼šCSS æ¼¸è®Šæ¨¡æ“¬é›™å±¤å¤¾å¿ƒ (ä¸Šç™½ä¸‹ç¶ ) */
            background: linear-gradient(to bottom, 
                #e0e0e0 0%, #d0d0d0 35%, /* éª¨å±¤ (ç´„35%) */
                #003319 35%, #004d26 100%); /* èƒŒå±¤ (ç´„65%) */
            border: 1px solid rgba(0,0,0,0.1);
            border-top: none;
        }
        
        /* v38: é›™å±¤å´é¢ (Right) - ç™½éª¨+ç¶ èƒŒ */
        .tile::after {
            content: ''; position: absolute; width: var(--depth); height: 100%;
            top: 0; right: 0;
            transform-origin: right; transform: rotateY(90deg);
            border-radius: 0 6px 6px 0;
            /* é—œéµï¼šCSS æ¼¸è®Šæ¨¡æ“¬é›™å±¤å¤¾å¿ƒ (å·¦ç™½å³ç¶ ) - æ³¨æ„æ–¹å‘ */
            background: linear-gradient(to right, 
                #ededed 0%, #dedede 35%, 
                #003d1e 35%, #00592e 100%);
            border: 1px solid rgba(0,0,0,0.1);
            border-left: none;
        }

        /* é–å®šç‹€æ…‹ */
        .tile.locked { 
            background-color: #ddd; 
            filter: brightness(0.9);
        }
        .tile.locked img, .tile.locked .t-icon { opacity: 0.4; filter: grayscale(100%); }
        .tile.locked .t-text, .tile.locked .t-suit { color: #888; }

        /* é¸ä¸­ç‹€æ…‹ */
        .tile.selected { 
            background-color: #fff9c4; 
            transform: translateZ(calc(var(--base-z) + 15px)) !important; 
            z-index: 9999 !important;
            border: 2px solid #ffb300;
        }
        .tile.selected .tile-shadow-layer {
            box-shadow: 10px 15px 30px rgba(0,0,0,0.5), 20px 30px 50px rgba(0,0,0,0.2);
            transform: translateZ(-15px);
        }

        /* å…§å®¹æ¨£å¼ */
        .t-suit { 
            position: absolute; top: 2px; right: 4px; font-size: 10px; color: #666; line-height: 1; backface-visibility: hidden; font-weight: bold; 
            text-shadow: 0 1px 0 rgba(255,255,255,0.8);
        }
        .t-icon { 
            font-size: 28px; line-height: 1; margin-top: 2px; backface-visibility: hidden; 
            filter: drop-shadow(0 1px 0 rgba(255,255,255,1)) drop-shadow(0 1px 1px rgba(0,0,0,0.1));
        }
        .t-text { 
            font-size: 11px; font-weight: 900; margin-top: 0px; color: #222; backface-visibility: hidden; 
            text-shadow: 0 1px 0 rgba(255,255,255,0.8);
        }
        
        .c-red { color: #c62828; } .c-blue { color: #1565c0; } .c-green { color: #2e7d32; }

        #msg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); 
            display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center; padding: 20px;
        }
        .overlay-box {
            background: #fff; padding: 30px; border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.7); border: 3px solid #e0e0e0;
            max-width: 90%; color: #333;
        }
        .overlay-title { font-size: 36px; font-weight: bold; margin-bottom: 20px; color: #ffb300; text-shadow: 1px 1px 0 rgba(0,0,0,0.2); }
        .overlay-verse { 
            font-size: 22px; color: #0288d1; line-height: 1.6; 
            background: #e3f2fd; padding: 20px; border-radius: 15px; 
            width: 100%; margin-bottom: 20px; border: 2px solid #bbdefb;
            font-weight: bold; 
        }

        #watermark {
            position: absolute; bottom: 95px; left: 20px; font-size: 11px;
            color: rgba(255, 255, 255, 0.4); pointer-events: none; z-index: 150; font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<header>
    <select id="map-select" onchange="changeMap(this.value)">
        <option value="turtle_real">ğŸ¢ ç¶“å…¸é¾œèƒŒ (çœŸ)</option>
        <option value="random">ğŸ² ç„¡é™éš¨æ©Ÿ</option>
        <option value="castle">ğŸ° å …å›ºå ¡å£˜</option>
        <option value="cross">âœï¸ æ¦®è€€åæ¶</option>
        <option value="bridge">ğŸŒ‰ æ©å…¸ä¹‹æ©‹</option>
        <option value="towers">ğŸ—¼ é›™å­å¡”</option>
    </select>
    <div id="status">å‰©é¤˜: 0</div>
</header>

<div id="game-viewport">
    <div id="game-board"></div>
</div>

<footer>
    <div class="footer-btns">
        <button class="btn btn-blue" onclick="forceNewGame()">ğŸ”„ æ–°å±€</button>
        <button class="btn btn-orange" onclick="undoMove()">â†©ï¸ å¾©åŸ</button>
        <button class="btn" onclick="autoHint()">ğŸ’¡ æç¤º</button>
    </div>
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
        <div id="joystick-hint">è¦–è§’</div>
    </div>
</footer>

<div id="watermark">Powered by Google Gemini v38 (Dual-Layer + Half-Grid)</div>

<div id="msg-overlay">
    <div class="overlay-box">
        <div id="overlay-title" class="overlay-title"></div>
        <div id="overlay-verse" class="overlay-verse"></div>
        <button id="overlay-btn" class="btn" style="width: 220px; height: 50px; font-size: 20px;" onclick="forceNewGame()">æŒ‘æˆ°ä¸‹ä¸€é—œ</button>
    </div>
</div>

<script>
    const rawTiles = [
        {t:"æ‘©è¥¿", i:"ğŸŒŠ", s:"è¬", c:"c-red"}, {t:"å¤§è¡›", i:"ğŸ‘‘", s:"è¬", c:"c-red"},
        {t:"ä¿ç¾…", i:"ğŸ“œ", s:"è¬", c:"c-red"}, {t:"å½¼å¾—", i:"ğŸŸ", s:"è¬", c:"c-red"},
        {t:"ç´„æ‹¿", i:"ğŸ‹", s:"è¬", c:"c-red"}, {t:"é¦¬åˆ©äº", i:"ğŸ¤°", s:"è¬", c:"c-red"},
        {t:"äºä¼¯è˜­", i:"ğŸ‘", s:"è¬", c:"c-red"}, {t:"ä½†ä»¥ç†", i:"ğŸ¦", s:"è¬", c:"c-red"},
        {t:"æ•™æœƒ", i:"â›ª", s:"ç­’", c:"c-blue"}, {t:"è¥¿å¥ˆ", i:"â›°ï¸", s:"ç­’", c:"c-blue"},
        {t:"ç´…æµ·", i:"ğŸŒŠ", s:"ç­’", c:"c-blue"}, {t:"ä¼Šç”¸", i:"ğŸ", s:"ç­’", c:"c-blue"},
        {t:"åŠ åˆ©åˆ©", i:"ğŸ›¶", s:"ç­’", c:"c-blue"}, {t:"è–æ®¿", i:"ğŸ›ï¸", s:"ç­’", c:"c-blue"},
        {t:"è€¶åˆ©å“¥", i:"ğŸ§±", s:"ç­’", c:"c-blue"}, {t:"æ–¹èˆŸ", i:"ğŸš¢", s:"ç­’", c:"c-blue"},
        {t:"åæ¶", i:"âœï¸", s:"ç´¢", c:"c-green"}, {t:"è–ç¶“", i:"ğŸ“–", s:"ç´¢", c:"c-green"},
        {t:"äº”é¤…", i:"ğŸ", s:"ç´¢", c:"c-green"}, {t:"äºŒé­š", i:"ğŸŸ", s:"ç´¢", c:"c-green"},
        {t:"å¯¶è¡€", i:"ğŸ·", s:"ç´¢", c:"c-green"}, {t:"è–éˆ", i:"ğŸ•Šï¸", s:"ç´¢", c:"c-green"},
        {t:"ä¿¡", i:"ğŸ›¡ï¸", s:"ç•ª", c:"#333"}, {t:"æœ›", i:"âš“", s:"ç•ª", c:"#333"},
        {t:"æ„›", i:"â¤ï¸", s:"ç•ª", c:"#333"}, {t:"é˜¿å€‘", i:"ğŸ™", s:"ç•ª", c:"#333"},
        {t:"ç¦±å‘Š", i:"ğŸ¤²", s:"ç•ª", c:"#333"}, {t:"å¾©æ´»", i:"ğŸŒ…", s:"ç•ª", c:"#333"},
        {t:"æŒªäº", i:"ğŸŒˆ", s:"è¬", c:"c-red"}, {t:"ç´„æ›¸äº", i:"ğŸº", s:"è¬", c:"c-red"},
        {t:"ä»¥åˆ©äº", i:"ğŸ”¥", s:"è¬", c:"c-red"}, 
        {t:"è‘¡è„", i:"ğŸ‡", s:"ç´¢", c:"c-green"}, {t:"ç£çŸ³", i:"ğŸª¨", s:"ç´¢", c:"c-green"},
        {t:"äº®å…‰", i:"ğŸ’¡", s:"ç­’", c:"c-blue"}, {t:"å¤©åœ‹", i:"â˜ï¸", s:"ç­’", c:"c-blue"},
        {t:"å–œæ¨‚", i:"ğŸ˜„", s:"ç•ª", c:"#333"}
    ];
    
    const winVerses = ["æµæ·šæ’’ç¨®çš„ï¼Œå¿…æ­¡å‘¼æ”¶å‰²ã€‚(è©© 126:5)", "é‚£ç¾å¥½çš„ä»—æˆ‘å·²ç¶“æ‰“éäº†ã€‚(æå¾Œ 4:7)", "é è‘—é‚£åŠ çµ¦æˆ‘åŠ›é‡çš„ï¼Œå‡¡äº‹éƒ½èƒ½åšã€‚(è…“ 4:13)", "ä½ å€‘æ˜¯ä¸–ä¸Šçš„å…‰ã€‚(å¤ª 5:14)", "å¾—å‹çš„ï¼Œæˆ‘è¦è³œä»–åœ¨æˆ‘å¯¶åº§ä¸Šèˆ‡æˆ‘åŒåã€‚(å•Ÿ 3:21)"];
    const loseVerses = ["æˆ‘çš„æ©å…¸æ˜¯å¤ ä½ ç”¨çš„ã€‚(æ—å¾Œ 12:9)", "æ‡‰ç•¶ä¸€ç„¡æ›æ…®ï¼Œåªè¦å‡¡äº‹è—‰è‘—ç¦±å‘Šã€‚(è…“ 4:6)", "ä½ å€‘è¦ä¼‘æ¯ï¼Œè¦çŸ¥é“æˆ‘æ˜¯ç¥ã€‚(è©© 46:10)", "è¬äº‹éƒ½äº’ç›¸æ•ˆåŠ›ã€‚(ç¾… 8:28)"];

    // v38: åœ°åœ–è—åœ–æ”¯æ´å°æ•¸é»åº§æ¨™ (åŠæ ¼)
    const MapBlueprints = {
        turtle_real: () => generateTrueTurtle(), // æ–°å¢ï¼šçœŸé¾œèƒŒ
        castle: () => generateWall(6, 8),
        cross: () => generateCross(),
        bridge: () => generateBridge(),
        towers: () => generateTowers(),
        random: () => generateChaos()
    };

    // v38: çœŸæ­£çš„é‡‘å­—å¡”é¾œèƒŒé™£ (æ”¯æ´åŠæ ¼)
    function generateTrueTurtle() {
        let slots = [];
        // Layer 0: åŸºç¤å¤§ç›¤ (12x8 ç´„ç•¥)
        // ç°¡åŒ–ç‰ˆé¾œèƒŒçµæ§‹
        for(let r=0; r<8; r++) for(let c=0; c<10; c++) slots.push([0, r, c]);
        
        // Layer 1: ç¸®å°ä¸€åœˆ (6x6)
        for(let r=1; r<7; r++) for(let c=2; c<8; c++) slots.push([1, r, c]);
        
        // Layer 2: å†ç¸®å° (4x4)
        for(let r=2; r<6; r++) for(let c=3; c<7; c++) slots.push([2, r, c]);
        
        // Layer 3: (2x2)
        for(let r=3; r<5; r++) for(let c=4; c<6; c++) slots.push([3, r, c]);
        
        // Layer 4: é ‚éƒ¨å–®å¼µ (æ”¾åœ¨åå­—ä¸­å¿ƒ) -> 3.5, 4.5
        slots.push([4, 3.5, 4.5]);
        
        // å·¦å³è€³æœµ (Layer 0 ç‰¹æ®Šä½)
        slots.push([0, 3.5, -1]); slots.push([0, 3.5, 10]);
        slots.push([0, 3.5, -2]); slots.push([0, 3.5, 11]);

        return slots;
    }

    function generateWall(rows, cols) { let slots=[]; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) { slots.push([0, r, c]); if(r===0||r===rows-1||c===0||c===cols-1) slots.push([1, r, c]); } return slots; }
    function generateCross() { let slots=[]; for(let r=0;r<8;r++) { slots.push([0,r,3]); slots.push([0,r,4]); slots.push([1,r,3]); } for(let c=0;c<8;c++) { slots.push([0,2,c]); slots.push([0,3,c]); slots.push([1,2,c]); } slots.push([2,2,3]); slots.push([2,3,3]); return slots; }
    function generateBridge() { let slots=[]; for(let c=0;c<10;c++) { slots.push([0,2,c]); slots.push([0,3,c]); if(c<3||c>6) { slots.push([1,2,c]); slots.push([1,3,c]); slots.push([2,2,c]); } } return slots; }
    function generateTowers() { let slots=[]; for(let r=0;r<6;r++) for(let c=0;c<8;c++) { if(c<2||c>5) { slots.push([0,r,c]); slots.push([1,r,c]); if(r>1&&r<4) slots.push([2,r,c]); } else if(r===2||r===3) slots.push([0,r,c]); } return slots; }
    function generateChaos() { let slots=[]; for(let r=0;r<6;r++) for(let c=0;c<8;c++) slots.push([0,r,c]); for(let i=0;i<32;i++) slots.push([Math.floor(Math.random()*2)+1, Math.floor(Math.random()*4)+1, Math.floor(Math.random()*6)+1]); return slots; }

    let tiles = [];
    let selectedTile = null;
    let moveHistory = [];
    let tileW = 46, tileH = 60; // é…åˆæ¨£å¼èª¿æ•´å°ºå¯¸
    let globalScale = 1;
    let viewRotX = 25;
    let viewRotZ = 0;

    function changeMap(val) { startGame(val); }
    function forceNewGame() { startGame(document.getElementById('map-select').value); }

    function startGame(mapType) {
        document.getElementById('msg-overlay').style.display = 'none';
        const board = document.getElementById('game-board');
        board.innerHTML = ''; tiles = []; selectedTile = null; moveHistory = [];
        
        let slots = MapBlueprints[mapType]();
        
        // ç¢ºä¿å¶æ•¸å¼µ
        if(slots.length % 2 !== 0) slots.pop();
        
        // ç½®ä¸­è¨ˆç®— (æ”¯æ´å°æ•¸é»)
        let minC = Infinity, maxC = -Infinity, minR = Infinity, maxR = -Infinity;
        slots.forEach(s => { 
            if(s[1]<minR) minR=s[1]; if(s[1]>maxR) maxR=s[1];
            if(s[2]<minC) minC=s[2]; if(s[2]>maxC) maxC=s[2];
        });
        
        // å°‡ä¸­å¿ƒé»ç§»åˆ° (0,0) ä»¥ä¾¿ transform å±…ä¸­
        let centerR = (minR + maxR) / 2;
        let centerC = (minC + maxC) / 2;
        
        // å»ºç«‹è™›æ“¬ç‰Œçµ„
        let virtualTiles = slots.map((s, i) => ({ 
            id: i, z: s[0], r: s[1] - centerR, c: s[2] - centerC, active: true 
        }));

        // é€†å‘ç”Ÿæˆé…å°
        let pairs = [], tempTiles, success = false, attempt = 0;
        while(!success && attempt < 50) { // å¢åŠ å˜—è©¦æ¬¡æ•¸å› ç‚ºé‚è¼¯è®Šè¤‡é›œ
            tempTiles = JSON.parse(JSON.stringify(virtualTiles)); pairs = []; let possible = true;
            while(tempTiles.some(t => t.active)) {
                let available = getAvailableTiles(tempTiles);
                if(available.length < 2) { possible = false; break; }
                
                // éš¨æ©Ÿé¸ä¸€å°
                let idx1 = Math.floor(Math.random()*available.length);
                let t1 = available.splice(idx1, 1)[0];
                let idx2 = Math.floor(Math.random()*available.length);
                let t2 = available.splice(idx2, 1)[0]; // ç°¡å–®éš¨æ©Ÿ
                
                // åœ¨ tempTiles ä¸­æ¨™è¨˜ç‚ºå·²æ¶ˆé™¤
                // é€™è£¡è¦æ‰¾å›åŸå§‹å¼•ç”¨ä¾†ä¿®æ”¹ active
                tempTiles.find(t=>t.id===t1.id).active = false;
                tempTiles.find(t=>t.id===t2.id).active = false;
                
                pairs.push([t1.id, t2.id]);
            }
            if(possible) success = true; attempt++;
        }
        // ä¿åº•ï¼šè‹¥ç”Ÿæˆå¤±æ•—ï¼ŒæŒ‰é †åºé…å°
        if(!success) { console.log("ç”Ÿæˆå¤±æ•—ï¼Œä½¿ç”¨ä¿åº•"); pairs=[]; for(let i=0;i<virtualTiles.length;i+=2) pairs.push([virtualTiles[i].id, virtualTiles[i+1].id]); }

        // åˆ†é…ç‰Œé¢
        let totalPairs = pairs.length, cardInventory = [], shuffledTypes = [...rawTiles].sort(()=>Math.random()-0.5);
        let typeIndex = 0;
        for(let i=0; i<totalPairs; i+=2) { // ç°¡å–®è¼ªæ›¿ï¼Œä¸å¼·æ±‚æ¯ç¨®éƒ½å‡º
            let card = shuffledTypes[typeIndex % shuffledTypes.length];
            cardInventory.push(card); if(i+1<totalPairs) cardInventory.push(card); // å…©å°åŒæ¨£çš„ç‰Œ(4å¼µ)
            typeIndex++;
        }
        // å¦‚æœç‰Œæ•¸å¤šï¼Œè£œæ»¿åº«å­˜
        while(cardInventory.length < totalPairs) {
             cardInventory.push(shuffledTypes[Math.floor(Math.random()*shuffledTypes.length)]);
        }
        cardInventory.sort(()=>Math.random()-0.5);
        
        let finalTilesData = new Array(virtualTiles.length);
        pairs.forEach((pair, idx) => { 
            finalTilesData[pair[0]] = cardInventory[idx]; 
            finalTilesData[pair[1]] = cardInventory[idx]; 
        });

        renderTiles(virtualTiles, finalTilesData);
        setTimeout(fitBoard, 50);
        updateStatusText();
    }

    // --- v38 æ ¸å¿ƒé‚è¼¯ï¼šç‰©ç†è¦†è“‹åˆ¤å®š (åŠæ ¼æ”¯æ´) ---
    function getAvailableTiles(tileSet) {
        return tileSet.filter(t => t.active && !isBlocked(t, tileSet));
    }

    function isBlocked(tile, allTiles) {
        // 1. æª¢æŸ¥ä¸Šæ–¹æ˜¯å¦æœ‰ç‰Œå£“ä½ (Top blocked)
        // åªè¦ z æ¯”æˆ‘å¤§ï¼Œä¸” (r, c) è·é›¢ < 1 (å³äº’ç›¸é‡ç–Š)ï¼Œå°±æ˜¯å£“ä½
        let isCovered = allTiles.some(other => 
            other.active && 
            other.id !== tile.id && 
            other.z > tile.z && 
            Math.abs(other.r - tile.r) < 1 && 
            Math.abs(other.c - tile.c) < 1
        );
        if (isCovered) return true;

        // 2. æª¢æŸ¥å·¦å³æ˜¯å¦æœ‰é˜»æ“‹ (Side blocked)
        // è¦å‰‡ï¼šå·¦é‚Šæœ‰ç‰Œ OR å³é‚Šæœ‰ç‰Œï¼Œå‰‡è¢«é–ã€‚
        // å·¦é‚Šåˆ¤å®šï¼šåŒå±¤ (zç›¸åŒ)ï¼Œré‡ç–Š (abs < 1)ï¼Œc åœ¨æˆ‘å·¦é‚Š (other.c < tile.c) ä¸”ç·Šè²¼ (diff <= 1)
        let leftBlocked = allTiles.some(other => 
            other.active && 
            other.id !== tile.id && 
            other.z === tile.z && 
            Math.abs(other.r - tile.r) < 1 && 
            other.c < tile.c && (tile.c - other.c) <= 1 // è·é›¢<=1ä»£è¡¨ç·Šè²¼æˆ–é‡ç–Š
        );

        let rightBlocked = allTiles.some(other => 
            other.active && 
            other.id !== tile.id && 
            other.z === tile.z && 
            Math.abs(other.r - tile.r) < 1 && 
            other.c > tile.c && (other.c - tile.c) <= 1
        );

        return leftBlocked && rightBlocked;
    }

    // å¯¦æ™‚éŠæˆ²ä¸­çš„åˆ¤å®š (é‡å° DOM tiles)
    function checkLocked(tileObj) {
        return isBlocked(tileObj, tiles);
    }

    function renderTiles(slots, dataMap) {
        const board = document.getElementById('game-board');
        slots.forEach((slot, index) => {
            const el = document.createElement('div');
            el.className = 'tile';
            const card = dataMap[index];
            el.innerHTML = `<div class="tile-shadow-layer"></div><div class="t-suit">${card.s}</div><div class="t-icon ${card.c}">${card.i}</div><div class="t-text ${card.c}">${card.t}</div>`;
            
            // åº§æ¨™è½‰æ›ç‚ºåƒç´  (æ”¯æ´å°æ•¸é»)
            // ç‚ºäº†å±…ä¸­ï¼Œé€™è£¡çš„ slot.r/c å·²ç¶“æ˜¯ç›¸å°æ–¼ä¸­å¿ƒçš„åç§»é‡
            // ä½† absolute å®šä½é€šå¸¸å¾å·¦ä¸Šè§’ç®—ï¼Œæ‰€ä»¥æˆ‘å€‘åˆ©ç”¨ CSS transform: translate(-50%, -50%) ä¾†è™•ç†
            // é€™è£¡åªéœ€è¨­å®šç›¸å°è·é›¢
            let left = slot.c * tileW; 
            let top = slot.r * tileH; 
            let zHeight = slot.z * 10; // å±¤ç´šé«˜åº¦
            
            el.style.left = 0 + 'px'; // æ­¸é›¶ï¼Œå…¨é  transform
            el.style.top = 0 + 'px';
            
            // çµ„åˆè®Šæ›ï¼šä½ç½® + Zè»¸é«˜åº¦
            el.style.transform = `translate(${left}px, ${top}px) translateZ(${zHeight}px)`;
            
            // å„²å­˜åŸºç¤é«˜åº¦èˆ‡ä½ç½®ä¾›å¾ŒçºŒå‹•ç•«ä½¿ç”¨
            el.dataset.baseTrans = `translate(${left}px, ${top}px) translateZ(${zHeight}px)`;
            el.style.zIndex = Math.floor(slot.z * 100 + slot.r + slot.c + 1000); 
            
            const tileObj = { 
                el: el, data: card, 
                z: slot.z, r: slot.r, c: slot.c, 
                active: true, id: index 
            };
            el.onclick = () => onTileClick(tileObj);
            board.appendChild(el);
            tiles.push(tileObj);
        });
        updateLockStatus();
    }

    function updateLockStatus() { 
        tiles.forEach(t => { 
            if(!t.active) return; 
            t.isLocked = checkLocked(t); 
            t.el.classList.toggle('locked', t.isLocked); 
        }); 
    }

    function onTileClick(tile) {
        if(!tile.active || tile.isLocked) return;
        if(selectedTile === tile) { 
            tile.el.classList.remove('selected'); 
            tile.el.style.transform = tile.el.dataset.baseTrans; // æ¢å¾©åŸä½
            selectedTile = null; 
        }
        else if(selectedTile) {
            if(tile.data.t === selectedTile.data.t) {
                moveHistory.push([tile, selectedTile]);
                tile.active=false; selectedTile.active=false;
                tile.el.style.display='none'; selectedTile.el.style.display='none'; 
                selectedTile = null;
                updateLockStatus(); updateStatusText(); checkGameState();
            } else { 
                selectedTile.el.classList.remove('selected'); 
                selectedTile.el.style.transform = selectedTile.el.dataset.baseTrans;
                selectedTile = tile; 
                tile.el.classList.add('selected'); 
                // æµ®èµ·æ•ˆæœï¼šåœ¨åŸºç¤è®Šæ›ä¸Šç–ŠåŠ  Z è»¸ä½ç§»
                tile.el.style.transform = `${tile.el.dataset.baseTrans} translateZ(20px)`;
            }
        } else { 
            selectedTile = tile; 
            tile.el.classList.add('selected'); 
            tile.el.style.transform = `${tile.el.dataset.baseTrans} translateZ(20px)`;
        }
    }

    function undoMove() {
        if (moveHistory.length === 0) return; 
        const lastMove = moveHistory.pop();
        const tile1 = lastMove[0]; const tile2 = lastMove[1];
        tile1.active = true; tile2.active = true;
        tile1.el.style.display = ''; tile2.el.style.display = '';
        tile1.el.classList.remove('selected'); tile2.el.classList.remove('selected');
        
        // æ¢å¾©è®Šæ›
        tile1.el.style.transform = tile1.el.dataset.baseTrans;
        tile2.el.style.transform = tile2.el.dataset.baseTrans;

        if(selectedTile) { 
            selectedTile.el.classList.remove('selected'); 
            selectedTile.el.style.transform = selectedTile.el.dataset.baseTrans;
            selectedTile = null; 
        }
        updateLockStatus(); updateStatusText();
    }

    function checkGameState() { if(tiles.filter(t=>t.active).length===0) showModal('win'); else if(!hasAvailableMoves()) showModal('lose'); }
    
    // v38: æç¤ºé‚è¼¯ä¹Ÿè¦ç”¨æ–°çš„ block åˆ¤æ–·
    function hasAvailableMoves() {
        let free = tiles.filter(t=>t.active && !checkLocked(t));
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) return true;
        return false;
    }

    function showModal(type) {
        const overlay = document.getElementById('msg-overlay'), title = document.getElementById('overlay-title'), verse = document.getElementById('overlay-verse'), btn = document.getElementById('overlay-btn');
        if(type==='win') {
            title.innerText="ğŸ‰ å“ˆåˆ©è·¯äºï¼(å‹åˆ©)"; title.style.color="#ffb300"; verse.innerText=winVerses[Math.floor(Math.random()*winVerses.length)];
            btn.innerText="æŒ‘æˆ°ä¸‹ä¸€é—œ ğŸš€"; btn.onclick=()=>{ document.getElementById('map-select').value=['turtle_real','random','castle','cross','bridge','towers'][Math.floor(Math.random()*6)]; startGame(document.getElementById('map-select').value); };
            btn.className = "btn"; 
        } else {
            title.innerText="ğŸ’ª æ©å…¸å¤ ç”¨ (æš«æ™‚ç„¡è·¯)"; title.style.color="#4fc3f7"; verse.innerText=loseVerses[Math.floor(Math.random()*loseVerses.length)];
            btn.innerText="é‡æ–°é–‹å§‹ ğŸ”„"; btn.onclick=()=>forceNewGame();
            btn.className = "btn btn-blue"; 
        }
        overlay.style.display='flex';
    }

    function shuffleActiveTiles() {
        let active=tiles.filter(t=>t.active), datas=active.map(t=>t.data), attempt=0, solvable=false;
        let freeIndices=active.map((t,i)=>!checkLocked(t)?i:-1).filter(i=>i!==-1);
        while(!solvable && attempt<50) {
            datas.sort(()=>Math.random()-0.5); let seen=new Set();
            for(let i of freeIndices) { if(seen.has(datas[i].t)) { solvable=true; break; } seen.add(datas[i].t); }
            attempt++;
        }
        active.forEach((t,i)=>{ t.data=datas[i]; t.el.classList.remove('selected'); t.el.style.transform = t.el.dataset.baseTrans;
            t.el.innerHTML=`<div class="tile-shadow-layer"></div><div class="t-suit">${t.data.s}</div><div class="t-icon ${t.data.c}">${t.data.i}</div><div class="t-text ${t.data.c}">${t.data.t}</div>`; 
        });
        selectedTile=null; document.getElementById('game-board').style.opacity=0.5; setTimeout(()=>document.getElementById('game-board').style.opacity=1, 300);
        moveHistory = [];
    }

    function autoHint() {
        let free=tiles.filter(t=>t.active && !checkLocked(t));
        for(let i=0;i<free.length;i++) for(let j=i+1;j<free.length;j++) if(free[i].data.t === free[j].data.t) {
            free[i].el.style.transform += " scale(1.1)"; 
            free[j].el.style.transform += " scale(1.1)";
            free[i].el.style.filter = "brightness(1.2)";
            free[j].el.style.filter = "brightness(1.2)";
            setTimeout(()=>{ 
                if(free[i].active) { free[i].el.style.transform = free[i].el.dataset.baseTrans; free[i].el.style.filter = ""; }
                if(free[j].active) { free[j].el.style.transform = free[j].el.dataset.baseTrans; free[j].el.style.filter = ""; }
            }, 1000); return;
        }
        alert("ç›®å‰ç„¡è§£ï¼Œè«‹æŒ‰ã€Œæ´—ç‰Œã€ï¼");
    }

    function updateStatusText() { document.getElementById('status').innerText = "å‰©é¤˜: " + tiles.filter(t => t.active).length; }

    function applyViewTransform() {
        const board = document.getElementById('game-board');
        if(!board) return;
        // v38: åŸºç¤è¦–è§’
        board.style.transform = `translate(-50%, -50%) rotateX(${viewRotX}deg) rotateZ(${viewRotZ}deg) scale(${globalScale})`;
    }

    function fitBoard() {
        const board = document.getElementById('game-board');
        const view = document.getElementById('game-viewport');
        if(!board || !view) return;
        board.style.transform = 'none';
        const boardW = 600; const boardH = 600; // ä¼°è¨ˆå€¼
        const viewW = view.clientWidth; const viewH = view.clientHeight;
        globalScale = Math.min((viewW - 40) / boardW, (viewH - 40) / boardH);
        if(globalScale > 1.2) globalScale = 1.2;
        applyViewTransform();
    }
    window.addEventListener('resize', fitBoard);

    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');
    let isDragging = false;
    let startX, startY;
    let initialRotX, initialRotZ;

    function handleStart(e) {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
        initialRotX = viewRotX; initialRotZ = viewRotZ;
        joystickKnob.style.transition = 'none';
    }

    function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault(); 
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        const maxDist = 30;
        const dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
        const limitedDist = Math.min(dist, maxDist);
        const angle = Math.atan2(deltaY, deltaX);
        const knobX = Math.cos(angle) * limitedDist;
        const knobY = Math.sin(angle) * limitedDist;
        joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
        viewRotZ = initialRotZ + (deltaX * 0.5); 
        viewRotX = initialRotX - (deltaY * 0.5); 
        viewRotX = Math.max(0, Math.min(viewRotX, 60)); 
        applyViewTransform();
    }

    function handleEnd() {
        isDragging = false;
        joystickKnob.style.transition = 'transform 0.2s';
        joystickKnob.style.transform = 'translate(0, 0)';
    }

    joystickZone.addEventListener('mousedown', handleStart);
    joystickZone.addEventListener('touchstart', handleStart, {passive: false});
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('touchmove', handleMove, {passive: false});
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('touchend', handleEnd);

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('./sw.js')
                .then(function(registration) { console.log('SW OK'); }, function(err) { console.log('SW Fail'); });
        });
    }

    // å•Ÿå‹•é è¨­ç‚ºçœŸé¾œèƒŒ
    document.getElementById('map-select').value = 'turtle_real';
    startGame('turtle_real'); 
</script>
</body>
</html>
